# -*- coding: utf-8 -*-
"""OCR_Documentos_Notaria_SantaCruz (2).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NbExVIFzavT6X3Cd-vpqNczic8XBHsOW
"""

"""
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ”¥ SISTEMA OCR INTELIGENTE PARA NOTARÃA SANTA CRUZ
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Autor: TeAmoHachi
Fecha: 2025-01-14
VersiÃ³n: 1.0

DOCUMENTOS SOPORTADOS:
âœ… DNI Azul (formato antiguo)
âœ… DNI ElectrÃ³nico (formato nuevo)
âœ… Carnet de ExtranjerÃ­a
âœ… Pasaporte Peruano
âœ… Pasaporte Extranjero

REQUISITOS:
- Google Colab Pro (GPU activada)
- Python 3.10+
- PaddleOCR
- OpenCV

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PASO 1: VERIFICAR GPU (Colab Pro)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import subprocess
import sys

print("ğŸ” Verificando GPU disponible...")
print("=" * 70)

# Verificar NVIDIA GPU
try:
    gpu_info = subprocess.check_output(['nvidia-smi'], encoding='utf-8')
    print("âœ… GPU DETECTADA:")
    print(gpu_info)
except:
    print("âš ï¸ NO SE DETECTÃ“ GPU")
    print("ğŸ’¡ SOLUCIÃ“N:")
    print("   1. Ve a: Entorno de ejecuciÃ³n â†’ Cambiar tipo de entorno")
    print("   2. Selecciona: Acelerador de hardware â†’ T4 GPU")
    print("   3. Guarda y vuelve a ejecutar esta celda")
    sys.exit(1)

print("\nâœ… GPU lista para usar")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PASO 2: INSTALAR DEPENDENCIAS (VERSIONES FIJAS Y ESTABLES)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("ğŸ“¦ Instalando librerÃ­as con versiones compatibles...")
print("=" * 70)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PASO 1: LIMPIAR INSTALACIONES PREVIAS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\nğŸ§¹ Limpiando instalaciones previas...")
!pip uninstall -y -q paddlepaddle paddlepaddle-gpu paddleocr paddlex 2>/dev/null
print("   âœ… Limpieza completada")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PASO 2: INSTALAR NUMPY CORRECTO (CRÃTICO)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\nğŸ”§ Instalando NumPy 1.26.4 (compatible)...")
!pip install -q "numpy<2.0" --force-reinstall
print("   âœ… NumPy 1.26.4 instalado")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PASO 3: INSTALAR PADDLEPADDLE 2.6.1 (VERSIÃ“N ESTABLE)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\nğŸ”§ Instalando PaddlePaddle 2.6.1...")
!pip install -q paddlepaddle-gpu==2.6.1
print("   âœ… PaddlePaddle 2.6.1 instalado")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PASO 4: INSTALAR PADDLEOCR 2.7.3 (COMPATIBLE CON 2.6.1)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\nğŸ”§ Instalando PaddleOCR 2.7.3...")
!pip install -q paddleocr==2.7.3
print("   âœ… PaddleOCR 2.7.3 instalado")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PASO 5: INSTALAR DEPENDENCIAS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\nğŸ”§ Instalando OpenCV y dependencias...")
!pip install -q opencv-python-headless pillow shapely
print("   âœ… OpenCV instalado")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PASO 6: REINICIAR KERNEL (OBLIGATORIO)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\n" + "=" * 70)
print("âœ… INSTALACIÃ“N COMPLETADA")
print("=" * 70)

print("\nğŸ”„ REINICIANDO KERNEL...")
print("   â±ï¸ Se reiniciarÃ¡ en 3 segundos...")
print("\nğŸ’¡ DESPUÃ‰S DEL REINICIO (mensaje 'session crashed'):")
print("   1. Click en RECONNECT")
print("   2. Ejecuta celda 1 (verificar GPU)")
print("   3. Ejecuta celda 2B (verificaciÃ³n)")
print("   4. Ejecuta celda 3 (inicializar OCR)")

import time
time.sleep(3)

import os
os.kill(os.getpid(), 9)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CELDA 2A: INSTALAR NUMPY Y REINICIAR (PASO 1 de 2)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("ğŸ“¦ PASO 1: Instalando NumPy correcto...")
print("=" * 70)

# Limpiar versiones conflictivas
print("\nğŸ§¹ Limpiando NumPy anterior...")
!pip uninstall -y -q numpy 2>/dev/null

# Instalar NumPy 1.26.4
print("\nğŸ”§ Instalando NumPy 1.26.4...")
!pip install -q "numpy==1.26.4"

# Verificar instalaciÃ³n
import numpy as np
print(f"\nâœ… NumPy instalado: {np.__version__}")

if not np.__version__.startswith('1.26'):
    print("   âš ï¸ VersiÃ³n incorrecta, reintentando...")
    !pip install --force-reinstall -q "numpy==1.26.4"

print("\n" + "=" * 70)
print("âœ… NUMPY 1.26.4 INSTALADO")
print("=" * 70)

print("\nğŸ”„ REINICIANDO KERNEL...")
print("   Esto es OBLIGATORIO para que NumPy se cargue correctamente")
print("\nğŸ’¡ DESPUÃ‰S DEL REINICIO:")
print("   1. Click en RECONNECT")
print("   2. âš ï¸ NO ejecutes celda 2A de nuevo")
print("   3. âœ… Ejecuta celda 2B (instalar PaddleOCR)")

import time
time.sleep(3)

import os
os.kill(os.getpid(), 9)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CELDA 2B: INSTALAR PADDLEOCR (VERSIÃ“N MEJORADA - congela NumPy)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("ğŸ“¦ PASO 2: Instalando PaddleOCR con NumPy congelado...")
print("=" * 70)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Verificar NumPy inicial
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import numpy as np
print(f"\nğŸ” NumPy inicial: {np.__version__}")

if not np.__version__.startswith('1.26'):
    print("   âŒ ERROR: NumPy incorrecto")
    print("   Ejecuta celda 2A y reinicia nuevamente")
    raise Exception("NumPy incorrecto")
else:
    print("   âœ… NumPy 1.26.4 correcto")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Crear constraints.txt para BLOQUEAR NumPy
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\nğŸ”’ Creando restricciones para evitar upgrade de NumPy...")

with open('/tmp/constraints.txt', 'w') as f:
    f.write('numpy==1.26.4\n')
    f.write('scipy<1.14.0\n')  # VersiÃ³n compatible con NumPy 1.x

print("   âœ… Restricciones creadas")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Instalar PaddlePaddle (sin dependencias)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\nğŸ”§ Instalando PaddlePaddle 2.6.1...")
!pip install -q --no-deps paddlepaddle-gpu==2.6.1
!pip install -q -c /tmp/constraints.txt protobuf decorator astor
print("   âœ… PaddlePaddle instalado")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Instalar PaddleOCR (con restricciones de NumPy)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\nğŸ”§ Instalando PaddleOCR 2.7.3 con restricciones...")
!pip install -q --no-deps paddleocr==2.7.3
!pip install -q -c /tmp/constraints.txt \
    opencv-python-headless pillow shapely pyclipper lmdb tqdm \
    rapidfuzz pyyaml attrdict scipy scikit-image imgaug

print("   âœ… PaddleOCR instalado")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Verificar que NumPy NO cambiÃ³
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\nğŸ” Verificando que NumPy no cambiÃ³...")
import importlib
importlib.reload(np)
import numpy as np

print(f"   NumPy final: {np.__version__}")

if not np.__version__.startswith('1.26'):
    print("   âŒ NumPy cambiÃ³ a 2.x")
    print("   Forzando downgrade...")
    !pip install --force-reinstall -q "numpy==1.26.4"
    print("   âœ… NumPy restaurado")
else:
    print("   âœ… NumPy se mantuvo en 1.26.4")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VerificaciÃ³n final
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\n" + "=" * 70)
print("ğŸ” VERIFICANDO INSTALACIÃ“N FINAL")
print("=" * 70)

try:
    import paddle
    print(f"\nâœ… PaddlePaddle: {paddle.__version__}")
except Exception as e:
    print(f"âŒ Error: {e}")

try:
    import paddleocr
    print(f"âœ… PaddleOCR: {paddleocr.__version__}")
except Exception as e:
    print(f"âŒ Error: {e}")

try:
    import cv2
    print(f"âœ… OpenCV: {cv2.__version__}")
except Exception as e:
    print(f"âŒ Error: {e}")

print(f"âœ… NumPy: {np.__version__}")

print("\n" + "=" * 70)
print("âœ… INSTALACIÃ“N COMPLETA")
print("=" * 70)
print("\nğŸ’¡ Ahora ejecuta la celda 3 (Inicializar OCR)")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CELDA 2C: ARREGLAR SCIPY (opcional, solo si celda 3 falla)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("ğŸ”§ Arreglando scipy...")

# Desinstalar scipy corrupto
!pip uninstall -y scipy 2>/dev/null

# Reinstalar scipy compatible con NumPy 1.26.4
!pip install -q "scipy==1.11.4"

print("âœ… Scipy reinstalado")

# Verificar
try:
    import scipy
    print(f"âœ… Scipy: {scipy.__version__}")
except Exception as e:
    print(f"âš ï¸ Scipy sigue con error: {e}")
    print("   Pero PaddleOCR puede funcionar igual")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PASO 3: INICIALIZAR OCR (compatible con PaddleOCR 2.7.3)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("ğŸ¤– Inicializando motor OCR...")
print("=" * 70)
print("â±ï¸ Descargando modelos (solo la primera vez)...\n")

from paddleocr import PaddleOCR

# ConfiguraciÃ³n compatible con PaddleOCR 2.7.3
ocr_engine = PaddleOCR(
    use_angle_cls=True,  # Detectar orientaciÃ³n
    lang='es'            # Idioma espaÃ±ol
)

print("\nâœ… Motor OCR listo")
print("   ğŸ‡ªğŸ‡¸ Idioma: EspaÃ±ol")
print("   ğŸ¯ VersiÃ³n 2.7.3 (estable)")
print("   âš¡ GPU activada automÃ¡ticamente")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PRE-PROCESAMIENTO AVANZADO PARA DNI DETERIORADOS (v1.3 - ESCALA GRISES)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import cv2
import numpy as np
from PIL import Image, ImageEnhance

def mejorar_imagen_avanzada(imagen):
    """
    Mejora agresiva para DNI deteriorados, escaneados, en escala de grises

    VersiÃ³n 1.3:
    - Mejor binarizaciÃ³n para escala de grises
    - Estrategia dual: Otsu + Adaptativa
    - Auto-inversiÃ³n de texto
    - Sharpen optimizado

    Args:
        imagen: numpy array BGR

    Returns:
        imagen mejorada
    """

    # 1. Convertir a escala de grises si no lo estÃ¡
    if len(imagen.shape) == 3:
        gris = cv2.cvtColor(imagen, cv2.COLOR_BGR2GRAY)
    else:
        gris = imagen.copy()

    # 2. Reducir ruido (mantiene bordes)
    denoised = cv2.bilateralFilter(gris, 9, 75, 75)

    # 3. CLAHE (Contrast Limited Adaptive Histogram Equalization)
    # Ajustado para documentos escaneados
    clahe = cv2.createCLAHE(clipLimit=2.5, tileGridSize=(8, 8))
    contrast = clahe.apply(denoised)

    # 4. ESTRATEGIA DUAL: Probar Otsu y Adaptativa

    # Otsu (mejor para documentos escaneados uniformes)
    _, binary_otsu = cv2.threshold(
        contrast,
        0,
        255,
        cv2.THRESH_BINARY + cv2.THRESH_OTSU
    )

    # Adaptativa (mejor para iluminaciÃ³n no uniforme)
    binary_adaptive = cv2.adaptiveThreshold(
        contrast,
        255,
        cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv2.THRESH_BINARY,
        15,  # Ventana mÃ¡s grande para documentos
        5    # Constante ajustada
    )

    # 5. Elegir la mejor binarizaciÃ³n
    # Si Otsu tiene buen contraste, usarla; si no, usar adaptativa
    std_otsu = binary_otsu.std()
    std_adaptive = binary_adaptive.std()

    if std_otsu > 50:  # Otsu tiene buen contraste
        binary = binary_otsu
        print("      â†’ Usando binarizaciÃ³n Otsu")
    else:
        binary = binary_adaptive
        print("      â†’ Usando binarizaciÃ³n adaptativa")

    # 6. Operaciones morfolÃ³gicas (limpia manchas pequeÃ±as)
    kernel = np.ones((1, 1), np.uint8)
    cleaned = cv2.morphologyEx(binary, cv2.MORPH_CLOSE, kernel)

    # 7. Auto-inversiÃ³n si el texto es negro sobre blanco
    mean_value = cleaned.mean()
    if mean_value < 127:  # Fondo oscuro
        cleaned = cv2.bitwise_not(cleaned)
        print("      â†’ Imagen invertida (texto oscuro detectado)")

    # 8. Sharpen optimizado
    kernel_sharpen = np.array([
        [-1, -1, -1],
        [-1,  9, -1],
        [-1, -1, -1]
    ])
    sharpened = cv2.filter2D(cleaned, -1, kernel_sharpen)

    # 9. Suavizado final ligero (reduce artefactos del sharpen)
    final = cv2.GaussianBlur(sharpened, (3, 3), 0)

    # 10. Convertir de vuelta a BGR para OCR
    resultado = cv2.cvtColor(final, cv2.COLOR_GRAY2BGR)

    return resultado


def detectar_y_corregir_perspectiva(imagen):
    """
    Detecta si la imagen estÃ¡ inclinada y la corrige
    (Para fotos tomadas con Ã¡ngulo)

    VersiÃ³n 1.1: Bug fix en desempaquetado de lÃ­neas
    """

    try:
        gris = cv2.cvtColor(imagen, cv2.COLOR_BGR2GRAY) if len(imagen.shape) == 3 else imagen
        edges = cv2.Canny(gris, 50, 150, apertureSize=3)

        # Detectar lÃ­neas
        lines = cv2.HoughLines(edges, 1, np.pi / 180, 200)

        if lines is not None and len(lines) > 0:
            # Calcular Ã¡ngulo promedio
            angulos = []

            # lines tiene shape (n, 1, 2) â†’ [(rho, theta)]
            for line in lines[:10]:  # Solo primeras 10 lÃ­neas
                rho, theta = line[0]  # Desempaquetar correctamente
                angle = np.degrees(theta) - 90
                angulos.append(angle)

            if angulos:
                angulo_promedio = np.median(angulos)

                # Si estÃ¡ muy inclinado, rotar
                if abs(angulo_promedio) > 2:  # MÃ¡s de 2 grados
                    (h, w) = imagen.shape[:2]
                    center = (w // 2, h // 2)
                    M = cv2.getRotationMatrix2D(center, angulo_promedio, 1.0)
                    rotated = cv2.warpAffine(
                        imagen, M, (w, h),
                        flags=cv2.INTER_CUBIC,
                        borderMode=cv2.BORDER_REPLICATE
                    )
                    print(f"      â†’ Imagen rotada {angulo_promedio:.2f}Â°")
                    return rotated

    except Exception as e:
        # Si falla la correcciÃ³n, devolver imagen original
        print(f"      âš ï¸ No se pudo corregir perspectiva: {e}")

    return imagen


def analizar_calidad_detallada(imagen):
    """
    AnÃ¡lisis mÃ¡s profundo de calidad
    """

    gris = cv2.cvtColor(imagen, cv2.COLOR_BGR2GRAY) if len(imagen.shape) == 3 else imagen

    # Contraste (desviaciÃ³n estÃ¡ndar)
    contraste = gris.std()

    # Nitidez (Laplacian variance)
    nitidez = cv2.Laplacian(gris, cv2.CV_64F).var()

    # Brillo promedio
    brillo = gris.mean()

    # Detectar si es escala de grises o color
    if len(imagen.shape) == 3:
        es_color = np.std(imagen[:, :, 0] - imagen[:, :, 1]) > 5
    else:
        es_color = False

    # Detectar si es escaneo (muy uniforme en los bordes)
    borde_superior = gris[0:20, :].mean()
    borde_inferior = gris[-20:, :].mean()
    es_escaneo = abs(borde_superior - borde_inferior) < 10 and (borde_superior > 200 or borde_superior < 50)

    # Evaluar calidad
    calidad = "EXCELENTE"
    necesita_mejora = False

    if contraste < 40:
        calidad = "MALA"
        necesita_mejora = True
    elif contraste < 60:
        calidad = "REGULAR"
        necesita_mejora = True
    elif nitidez < 100:
        calidad = "REGULAR"
        necesita_mejora = True

    return {
        "contraste": contraste,
        "nitidez": nitidez,
        "brillo": brillo,
        "calidad": calidad,
        "es_color": es_color,
        "es_escaneo": es_escaneo,
        "necesita_mejora": necesita_mejora
    }


def pipeline_mejora_completo(imagen):
    """
    Pipeline completo de mejora para cualquier tipo de DNI
    """

    print("   ğŸ” Analizando calidad de imagen...")
    analisis = analizar_calidad_detallada(imagen)

    print(f"   ğŸ“Š Contraste: {analisis['contraste']:.2f}")
    print(f"   ğŸ“Š Nitidez: {analisis['nitidez']:.2f}")
    print(f"   ğŸ“Š Brillo: {analisis['brillo']:.2f}")
    print(f"   ğŸ“Š Calidad: {analisis['calidad']}")
    print(f"   ğŸ“Š Es escaneo: {'SÃ­' if analisis['es_escaneo'] else 'No'}")
    print(f"   ğŸ“Š Es color: {'SÃ­' if analisis['es_color'] else 'No (escala de grises)'}")

    if not analisis['necesita_mejora']:
        print("   âœ… Imagen con calidad suficiente, no requiere mejora")
        return imagen

    print(f"   ğŸ”§ Aplicando mejoras para imagen de calidad {analisis['calidad']}...")

    # 1. Corregir perspectiva si es necesario
    corregida = detectar_y_corregir_perspectiva(imagen)

    # 2. Aplicar mejoras avanzadas
    mejorada = mejorar_imagen_avanzada(corregida)

    print("   âœ… Imagen mejorada exitosamente")

    return mejorada


def decidir_estrategia_mejora(imagen, analisis):
    """
    Decide si usar mejora o imagen original segÃºn el caso

    Estrategias:
    - Escala de grises REGULAR: Probar ambas (original + mejorada)
    - Escala de grises MALA: Siempre mejorar
    - Color REGULAR/MALA: Siempre mejorar
    - EXCELENTE: No mejorar

    Args:
        imagen: numpy array BGR
        analisis: dict con anÃ¡lisis de calidad

    Returns:
        tuple: (imagen_final, usar_mejora)
    """

    # Caso 1: Excelente calidad â†’ no mejorar
    if not analisis['necesita_mejora']:
        print("   âœ… Imagen con calidad suficiente, no requiere mejora")
        return imagen, False

    # Caso 2: Escala de grises de calidad REGULAR
    # A veces OCR funciona mejor con la original
    if not analisis['es_color'] and analisis['calidad'] == 'REGULAR':
        print("   ğŸ’¡ Estrategia dual para escala de grises REGULAR:")
        print("      1. Probar con mejora agresiva")
        print("      2. Si falla, el sistema reintentarÃ¡ automÃ¡ticamente")

        mejorada = pipeline_mejora_completo(imagen)
        return mejorada, True

    # Caso 3: Otros casos â†’ aplicar mejoras
    print(f"   ğŸ”§ Aplicando mejoras para imagen de calidad {analisis['calidad']}...")
    mejorada = pipeline_mejora_completo(imagen)
    return mejorada, True


print("âœ… Sistema de pre-procesamiento avanzado v1.3")
print("   - BinarizaciÃ³n dual (Otsu + Adaptativa)")
print("   - Auto-inversiÃ³n de texto")
print("   - ReducciÃ³n de ruido bilateral")
print("   - CLAHE optimizado")
print("   - CorrecciÃ³n de perspectiva")
print("   - Sharpen + suavizado final")
print("   - Estrategia inteligente para escala de grises")
print("   - Soporte para documentos escaneados")
print("   - Soporte para DNI deteriorados")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EVALUACIÃ“N Y MEJORA DE CALIDAD DE IMAGEN (VERSIÃ“N v2.1)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import cv2
import numpy as np

def evaluar_calidad(imagen):
    """
    EvalÃºa la calidad de la imagen y aplica mejoras si es necesario

    VersiÃ³n 2.1:
    - Estrategia inteligente para escala de grises
    - DecisiÃ³n automÃ¡tica de mejora segÃºn tipo de imagen

    Args:
        imagen: numpy array BGR

    Returns:
        tuple: (imagen_mejorada, dict_analisis)
    """

    # AnÃ¡lisis detallado de calidad
    analisis = analizar_calidad_detallada(imagen)

    # Decidir estrategia de mejora
    imagen_final, usar_mejora = decidir_estrategia_mejora(imagen, analisis)

    return imagen_final, analisis


def mostrar_analisis_calidad(analisis):
    """
    Muestra un resumen visual del anÃ¡lisis de calidad
    """
    print(f"\nğŸ” Evaluando calidad de imagen...")
    print(f"   ğŸ“Š Contraste: {analisis['contraste']:.2f}")
    print(f"   ğŸ“Š Nitidez: {analisis['nitidez']:.2f}")
    print(f"   ğŸ“Š Calidad: {analisis['calidad']}")

    # InformaciÃ³n adicional
    if analisis.get('es_fotocopia', False):
        print(f"   ğŸ“„ Fotocopia detectada")

    if not analisis.get('es_color', True):
        print(f"   âš« Escala de grises detectada")

    if analisis.get('es_escaneo', False):
        print(f"   ğŸ“„ Escaneo detectado")


print("âœ… Sistema de evaluaciÃ³n de calidad v2.1")
print("   - AnÃ¡lisis automÃ¡tico mejorado")
print("   - Estrategia inteligente para escala de grises")
print("   - Mejora selectiva segÃºn tipo de imagen")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIONES AUXILIARES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def extraer_texto_limpio(resultado_ocr):
    """
    Convierte el resultado de PaddleOCR a texto plano limpio

    Args:
        resultado_ocr: Output de ocr.ocr()

    Returns:
        str: Texto extraÃ­do limpio
    """
    if not resultado_ocr or not resultado_ocr[0]:
        return ""

    lineas = []
    for linea in resultado_ocr[0]:
        texto = linea[1][0]  # [1][0] = texto detectado
        confianza = linea[1][1]  # [1][1] = confianza (0-1)

        # Solo incluir texto con confianza > 60%
        if confianza > 0.6:
            lineas.append(texto)

    return "\n".join(lineas)


def mostrar_resultado_ocr(resultado_ocr, titulo="Texto ExtraÃ­do"):
    """
    Muestra el resultado del OCR de forma bonita
    """
    print(f"\n{'=' * 70}")
    print(f"ğŸ“„ {titulo}")
    print(f"{'=' * 70}\n")

    if not resultado_ocr or not resultado_ocr[0]:
        print("âŒ No se detectÃ³ texto")
        return

    for i, linea in enumerate(resultado_ocr[0], 1):
        texto = linea[1][0]
        confianza = linea[1][1]

        # Color segÃºn confianza
        if confianza > 0.9:
            emoji = "âœ…"
        elif confianza > 0.7:
            emoji = "âš ï¸"
        else:
            emoji = "âŒ"

        print(f"{emoji} [{confianza*100:5.1f}%] {texto}")

    print(f"\n{'=' * 70}")


def mejorar_imagen_para_ocr(imagen):
    """
    Mejora fotocopias y fotos de baja calidad

    Aplica:
    - ConversiÃ³n a escala de grises
    - Aumento de contraste (CLAHE)
    - ReducciÃ³n de ruido
    - BinarizaciÃ³n adaptativa
    - Aumento de nitidez

    Args:
        imagen: numpy array (BGR)

    Returns:
        numpy array: Imagen mejorada
    """
    # 1) Convertir a escala de grises
    if len(imagen.shape) == 3:
        gray = cv2.cvtColor(imagen, cv2.COLOR_BGR2GRAY)
    else:
        gray = imagen

    # 2) Aumentar contraste (hace el texto mÃ¡s visible)
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    enhanced = clahe.apply(gray)

    # 3) Reducir ruido (suaviza manchas de fotocopia)
    denoised = cv2.fastNlMeansDenoising(enhanced, h=10)

    # 4) BinarizaciÃ³n adaptativa (texto negro sobre blanco)
    binary = cv2.adaptiveThreshold(
        denoised,
        255,
        cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
        cv2.THRESH_BINARY,
        11,
        2
    )

    # 5) Aumentar nitidez
    kernel = np.array([[-1, -1, -1],
                       [-1,  9, -1],
                       [-1, -1, -1]])
    sharpened = cv2.filter2D(binary, -1, kernel)

    return sharpened


def cargar_imagen(ruta_o_bytes):
    """
    Carga imagen desde archivo o bytes

    Args:
        ruta_o_bytes: str (ruta) o bytes (archivo subido)

    Returns:
        numpy array: Imagen en formato BGR
    """
    if isinstance(ruta_o_bytes, str):
        # Es una ruta de archivo
        imagen = cv2.imread(ruta_o_bytes)
    else:
        # Es bytes (archivo subido en Streamlit/Colab)
        imagen = cv2.imdecode(
            np.frombuffer(ruta_o_bytes.read(), np.uint8),
            cv2.IMREAD_COLOR
        )

    return imagen


def detectar_calidad_imagen(imagen):
    """
    EvalÃºa la calidad de la imagen

    Returns:
        dict: {
            "contraste": float,
            "nitidez": float,
            "es_fotocopia": bool,
            "calidad": str ("EXCELENTE" | "BUENA" | "REGULAR" | "MALA")
        }
    """
    # Convertir a gris si es necesario
    if len(imagen.shape) == 3:
        gray = cv2.cvtColor(imagen, cv2.COLOR_BGR2GRAY)
    else:
        gray = imagen

    # Calcular contraste (desviaciÃ³n estÃ¡ndar)
    contraste = gray.std()

    # Calcular nitidez (Laplacian variance)
    laplacian = cv2.Laplacian(gray, cv2.CV_64F)
    nitidez = laplacian.var()

    # Determinar si es fotocopia (bajo contraste)
    es_fotocopia = contraste < 50

    # Clasificar calidad
    if contraste > 60 and nitidez > 500:
        calidad = "EXCELENTE"
    elif contraste > 45 and nitidez > 300:
        calidad = "BUENA"
    elif contraste > 30:
        calidad = "REGULAR"
    else:
        calidad = "MALA"

    return {
        "contraste": contraste,
        "nitidez": nitidez,
        "es_fotocopia": es_fotocopia,
        "calidad": calidad
    }


print("âœ… Funciones auxiliares cargadas")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DETECTORES DE TIPO DE DOCUMENTO (VERSIÃ“N v3.2 - FLEXIBLE)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import re

def limpiar_texto_ocr(texto):
    """Limpia texto del OCR para mejorar detecciÃ³n"""
    texto = texto.upper()
    texto = texto.replace('Ãš', 'U').replace('Ã‰', 'E').replace('Ã', 'A')
    texto = texto.replace('Ã', 'I').replace('Ã“', 'O').replace('Ã‘', 'N')
    texto = re.sub(r'\s+', ' ', texto)
    return texto


def detectar_tipo_documento(texto_ocr):
    """
    Detecta el tipo de documento automÃ¡ticamente (VERSIÃ“N v3.2 FLEXIBLE)
    Mejoras: Acepta variantes con y sin espacios del OCR
    """
    texto = limpiar_texto_ocr(texto_ocr)

    patterns = {
        "DNI_AZUL": {
            "palabras": [
                "DOCUMENTO NACIONAL DE IDENTIDAD",
                "DOCUMENTONACIONAL DE IDENTIDAD",
                "DOCUMENTONACIONALDEIDENTIDAD",
                "REPUBLICA DEL PERU",
                "REPUBLICADEL PERU",
                "REPUBLICADELPERU",
                "REGISTRO NACIONAL DE IDENTIFICACION",
                "REGISTRONACIONAL DE IDENTIFICACION",
                "REGISTRONACIONALDEIDENTIFICACION",
                # Variantes de apellido (con y sin espacio)
                "Primer Apellido",
                "PRIMERAPELLIDO",
                "Segundo Apellido",
                "SEGUNDOAPELLIDO",
                # Variantes de nombres (CLAVE para DNI Azul)
                "Pre Nombres",
                "PRE NOMBRES",
                "PRENOMBRES",
                "CUI",
                # Penalizar palabras exclusivas de electrÃ³nico
                "!CONSTANCIA"  # Solo electrÃ³nico tiene esto visible
            ],
            "score_minimo": 4
        },

        "DNI_ELECTRONICO": {
            "palabras": [
                "DOCUMENTO NACIONAL DE IDENTIDAD",
                "DOCUMENTONACIONAL DE IDENTIDAD",
                "DOCUMENTONACIONALDEIDENTIDAD",
                "REPUBLICA DEL PERU",
                "REPUBLICADEL PERU",
                "REPUBLICADELPERU",
                "REGISTRO NACIONAL",
                "REGISTRONACIONAL",
                "CUI",
                "PRENOMBRES",
                "PRIMERAPELLIDO",
                "SEGUNDOAPELLIDO",
                # CLAVE: ElectrÃ³nico tiene "Constancia" muy visible
                "CONSTANCIA"
            ],
            "score_minimo": 5
        },

        "CARNET_EXTRANJERIA": {
            "palabras": [
                "SUPERINTENDENCIA NACIONAL DE MIGRACIONES",
                "SUPERINTENDENCIANACIONAL DEMIGRACIONES",
                "CARNE DE EXTRANJERIA",
                "CARNEDE EXTRANJERIA",
                "CALIDAD MIGRATORIA",
                "CALIDADMIGRATORIA",
                "MIGRACIONES PERU",
                "MIGRACIONESPERU"
            ],
            "score_minimo": 2
        },

        "PASAPORTE_PERUANO": {
            "palabras": [
                "PASSPORT",
                "PASAPORTE",
                "REPUBLICA DEL PERU",
                "REPUBLICADEL PERU",
                "P<PER",
                "TYPE P",
                "TIPO P"
            ],
            "score_minimo": 2
        },

        "PASAPORTE_EXTRANJERO": {
            "palabras": [
                "PASSPORT",
                "PASSEPORT",
                "P<USA", "P<ESP", "P<ARG", "P<COL", "P<VEN",
                "P<CHL", "P<BRA", "P<ECU", "P<BOL", "P<MEX"
            ],
            "score_minimo": 1
        }
    }

    scores = {}

    for tipo, config in patterns.items():
        score = 0

        for palabra in config["palabras"]:
            if palabra.startswith("!"):
                # PenalizaciÃ³n: NO debe contener esta palabra
                palabra_limpia = palabra[1:]
                if palabra_limpia in texto:
                    score -= 5
            else:
                # BonificaciÃ³n: SÃ debe contener esta palabra
                if palabra in texto:
                    score += 1

        scores[tipo] = score

    # Ordenar por score descendente
    tipos_ordenados = sorted(scores.items(), key=lambda x: x[1], reverse=True)
    mejor_tipo, mejor_score = tipos_ordenados[0]
    score_minimo = patterns[mejor_tipo]["score_minimo"]

    # Verificar si cumple el mÃ­nimo
    if mejor_score >= score_minimo:
        info_tipos = {
            "DNI_AZUL": {"formato": "ANTIGUO", "color": "AZUL_TURQUESA", "pais": "PERU"},
            "DNI_ELECTRONICO": {"formato": "NUEVO", "color": "BEIGE_CREMA", "pais": "PERU"},
            "CARNET_EXTRANJERIA": {"formato": "MIGRACIONES", "color": "ROSA_AMARILLO", "pais": "PERU"},
            "PASAPORTE_PERUANO": {"formato": "PASAPORTE", "color": "VINO_TINTO", "pais": "PERU"},
            "PASAPORTE_EXTRANJERO": {"formato": "PASAPORTE", "color": "VARIA", "pais": "EXTRANJERO"}
        }

        info = info_tipos[mejor_tipo]
        confianza = min(mejor_score / (score_minimo + 2), 1.0)

        return {
            "tipo": mejor_tipo,
            "formato": info["formato"],
            "color": info["color"],
            "pais": info["pais"],
            "confianza": confianza,
            "score": mejor_score,
            "debug_scores": scores
        }

    # No se pudo identificar
    return {
        "tipo": "DESCONOCIDO",
        "formato": None,
        "color": None,
        "pais": None,
        "confianza": 0.0,
        "score": mejor_score,
        "debug_scores": scores
    }


def mostrar_deteccion(deteccion):
    """Muestra el resultado de detecciÃ³n"""
    print(f"\n{'=' * 70}")
    print("ğŸ” DETECCIÃ“N DE DOCUMENTO")
    print(f"{'=' * 70}\n")

    tipo = deteccion["tipo"]
    confianza = deteccion["confianza"]

    if tipo == "DESCONOCIDO":
        print("âŒ NO SE PUDO IDENTIFICAR EL DOCUMENTO")
        print("\nğŸ“Š Scores de detecciÃ³n (debug):")
        for t, s in deteccion["debug_scores"].items():
            print(f"   {t}: {s} puntos")
        return

    emojis = {
        "DNI_AZUL": "ğŸ”µ",
        "DNI_ELECTRONICO": "ğŸ†•",
        "CARNET_EXTRANJERIA": "ğŸŒ",
        "PASAPORTE_PERUANO": "ğŸ‡µğŸ‡ª",
        "PASAPORTE_EXTRANJERO": "ğŸ›‚"
    }

    emoji = emojis.get(tipo, "ğŸ“„")

    print(f"{emoji} TIPO: {tipo.replace('_', ' ')}")
    print(f"ğŸ“Š CONFIANZA: {confianza*100:.1f}%")
    print(f"ğŸ“Š SCORE: {deteccion['score']} puntos")
    print(f"ğŸ¨ COLOR: {deteccion.get('color', 'N/A')}")
    print(f"ğŸŒ PAÃS: {deteccion.get('pais', 'N/A')}")

    print(f"\nğŸ“Š Scores de todos los tipos:")
    for t, s in deteccion["debug_scores"].items():
        simbolo = "âœ…" if t == tipo else "  "
        print(f"   {simbolo} {t}: {s} puntos")

    necesita_reverso = tipo in ["DNI_AZUL", "DNI_ELECTRONICO", "CARNET_EXTRANJERIA"]

    if necesita_reverso:
        print(f"\nâš ï¸  REQUIERE FOTO DEL REVERSO")
        print("   (Para obtener direcciÃ³n completa)")
    else:
        print(f"\nâœ… NO REQUIERE REVERSO")

    print(f"\n{'=' * 70}")


print("âœ… Detector de documentos v3.2 (flexible con variantes OCR)")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PARSER 1: DNI (VERSIÃ“N v5.3 - FECHA NACIMIENTO CORREGIDA)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def parsear_dni(texto_ocr, tipo_dni="DNI_AZUL"):
    """
    Extrae campos de DNI (ElectrÃ³nico o Azul)

    VersiÃ³n 5.3:
    - CorrecciÃ³n de fecha de nacimiento (prioriza fecha cerca de "Nacimiento")
    - ValidaciÃ³n de datos antes de guardar
    - ExtracciÃ³n desde MRZ como backup robusto

    Autor: TeAmoHachi
    Fecha: 2025-11-14
    """
    import re
    from datetime import datetime

    datos = {}

    lineas = [l.strip() for l in texto_ocr.split('\n') if l.strip()]

    def buscar_indice(palabra_clave):
        for i, linea in enumerate(lineas):
            if re.search(palabra_clave, linea, re.IGNORECASE):
                return i
        return -1

    def es_dato_valido(texto):
        """Valida que no sea una etiqueta de fecha u otro dato invÃ¡lido"""
        invalidos = ['FECHA', 'INSCRIPCION', 'EMISION', 'CADUCIDAD', 'NACIMIENTO', 'UBIGEO', 'SEXO', 'ESTADO', 'CIVIL']
        texto_upper = texto.upper()

        # Si contiene palabras invÃ¡lidas
        if any(inv in texto_upper for inv in invalidos):
            return False

        # Si es solo nÃºmeros (fecha)
        if re.match(r'^\d+$', texto):
            return False

        # Si es muy corto
        if len(texto.strip()) < 2:
            return False

        return True

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 1. DNI (desde header o MRZ)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # DNI desde header: DNI80471727-7
    dni_header = re.search(r'DNI\s*(\d{8})', texto_ocr, re.IGNORECASE)
    if dni_header:
        datos["dni"] = dni_header.group(1)

    # DNI desde MRZ: I<PER80471727<2
    if "dni" not in datos:
        for linea in lineas:
            if 'I<PER' in linea:
                dni_mrz = re.search(r'I<PER(\d{8})', linea)
                if dni_mrz:
                    datos["dni"] = dni_mrz.group(1)
                    break

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 2. APELLIDOS Y NOMBRES (con validaciÃ³n)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # Primer Apellido (DNI Azul y ElectrÃ³nico)
    idx_ap1 = buscar_indice(r'Primer\s*Apellido')
    if idx_ap1 >= 0:
        # Buscar en las siguientes 3 lÃ­neas el primer valor vÃ¡lido
        for i in range(idx_ap1 + 1, min(idx_ap1 + 4, len(lineas))):
            candidato = lineas[i]
            if es_dato_valido(candidato) and re.match(r'^[A-ZÃÃ‰ÃÃ“ÃšÃ‘\s]+$', candidato):
                datos["apellido_paterno"] = candidato
                break

    # Segundo Apellido
    idx_ap2 = buscar_indice(r'Segundo\s*Apellido')
    if idx_ap2 >= 0:
        for i in range(idx_ap2 + 1, min(idx_ap2 + 4, len(lineas))):
            candidato = lineas[i]
            if es_dato_valido(candidato) and re.match(r'^[A-ZÃÃ‰ÃÃ“ÃšÃ‘\s]+$', candidato):
                datos["apellido_materno"] = candidato
                break

    # Pre Nombres (DNI Azul) o Prenombres (ElectrÃ³nico)
    idx_prenombres = buscar_indice(r'Pre\s*Nombres?|Prenombres?')
    if idx_prenombres >= 0:
        for i in range(idx_prenombres + 1, min(idx_prenombres + 4, len(lineas))):
            candidato = lineas[i]
            if es_dato_valido(candidato) and re.match(r'^[A-ZÃÃ‰ÃÃ“ÃšÃ‘\s]+$', candidato):
                # Separar si estÃ¡ pegado (MARIAISABEL â†’ MARIA ISABEL)
                nombres = candidato

                if len(nombres.replace(' ', '')) > 10:
                    nombres = re.sub(
                        r'(MARIA|MONICA|MILAGROS|JUAN|JOSE|LUIS|CARLOS|PEDRO|ANA|ROSA|CARMEN|TERESA|ISABEL|GLORIA|PATRICIA|ALEJANDRA|FERNANDA|CAROLINA|DANIELA|ANDREA|CLAUDIA|VALENTINA|SOFIA|CAMILA|GABRIELA)([A-Z])',
                        r'\1 \2',
                        nombres
                    )

                datos["nombres"] = re.sub(r'\s+', ' ', nombres.strip())
                break

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 3. BACKUP: EXTRAER DESDE MRZ SI FALTAN DATOS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if "nombres" not in datos or "apellido_paterno" not in datos:
        # LÃ­nea 3 MRZ: CASAS<<MARIA<ISABEL<<<<<
        for linea in lineas:
            if linea.count('<') > 5 and not linea.startswith('I<PER'):
                mrz_match = re.match(r'^([A-Z]+)<<([A-Z<]+)$', linea)
                if mrz_match:
                    apellido_mrz = mrz_match.group(1)
                    nombres_mrz = mrz_match.group(2).replace('<', ' ').strip()

                    if "apellido_paterno" not in datos:
                        datos["apellido_paterno"] = apellido_mrz

                    if "nombres" not in datos:
                        datos["nombres"] = nombres_mrz

                    break

    # Nombre completo
    if all(k in datos for k in ["nombres", "apellido_paterno", "apellido_materno"]):
        datos["nombre_completo"] = f"{datos['nombres']} {datos['apellido_paterno']} {datos['apellido_materno']}"
    elif all(k in datos for k in ["nombres", "apellido_paterno"]):
        datos["nombre_completo"] = f"{datos['nombres']} {datos['apellido_paterno']}"

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 4. FECHA DE NACIMIENTO (CORREGIDA v5.3)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # Formato: DDMMYYYY (05112002)
    # Estrategia: Priorizar fecha cerca de "Nacimiento"

    fechas_encontradas = re.findall(r'\b([0-3]\d)([0-1]\d)(19\d{2}|20[0-2]\d)\b', texto_ocr)
    fecha_nacimiento_final = None

    # ESTRATEGIA 1: Buscar cerca de la palabra "Nacimiento"
    idx_nacimiento = buscar_indice(r'Nacimiento')
    if idx_nacimiento >= 0:
        # Buscar fecha en las siguientes 3 lÃ­neas
        for i in range(idx_nacimiento, min(idx_nacimiento + 3, len(lineas))):
            linea = lineas[i]
            fnac_local = re.search(r'\b([0-3]\d)([0-1]\d)(19\d{2}|20[0-2]\d)\b', linea)
            if fnac_local:
                dia, mes, anio = fnac_local.groups()
                try:
                    fecha_nac = datetime(int(anio), int(mes), int(dia))
                    hoy = datetime.now()
                    edad = (hoy - fecha_nac).days // 365

                    # Validar que sea una edad lÃ³gica
                    if 0 <= edad <= 120:
                        fecha_nacimiento_final = (dia, mes, anio, edad)
                        break
                except:
                    pass

    # ESTRATEGIA 2: Si no encontrÃ³, tomar la fecha mÃ¡s antigua (mayor edad)
    if not fecha_nacimiento_final and fechas_encontradas:
        mejor_edad = 0

        for dia, mes, anio in fechas_encontradas:
            try:
                fecha_nac = datetime(int(anio), int(mes), int(dia))
                hoy = datetime.now()
                edad = (hoy - fecha_nac).days // 365

                # Validar rango lÃ³gico y tomar la mayor edad (mÃ¡s antigua)
                if 0 <= edad <= 120 and edad > mejor_edad:
                    fecha_nacimiento_final = (dia, mes, anio, edad)
                    mejor_edad = edad
            except:
                pass

    # Guardar fecha de nacimiento
    if fecha_nacimiento_final:
        dia, mes, anio, edad = fecha_nacimiento_final
        datos["fecha_nacimiento"] = f"{dia}/{mes}/{anio}"
        datos["fecha_nacimiento_iso"] = f"{anio}-{mes}-{dia}"
        datos["edad"] = edad

    # ESTRATEGIA 3: Backup desde MRZ (lÃ­nea 2: 0211051F2711195PER)
    if "fecha_nacimiento" not in datos:
        for linea in lineas:
            if len(linea) > 6 and 'F' in linea and 'PER' in linea:
                fnac_mrz = re.match(r'^(\d{2})(\d{2})(\d{2})', linea)
                if fnac_mrz:
                    anio_corto, mes, dia = fnac_mrz.groups()
                    anio = f"20{anio_corto}" if int(anio_corto) < 50 else f"19{anio_corto}"

                    try:
                        fecha_nac = datetime(int(anio), int(mes), int(dia))
                        hoy = datetime.now()
                        edad = (hoy - fecha_nac).days // 365

                        if 0 <= edad <= 120:
                            datos["fecha_nacimiento"] = f"{dia}/{mes}/{anio}"
                            datos["fecha_nacimiento_iso"] = f"{anio}-{mes}-{dia}"
                            datos["edad"] = edad
                            break
                    except:
                        pass

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 5. SEXO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    sexo_match = re.search(r'Sexo[:\s]*\n?\s*([MF])\b', texto_ocr, re.IGNORECASE)
    if sexo_match:
        datos["sexo"] = sexo_match.group(1).upper()
        datos["sexo_completo"] = "MASCULINO" if datos["sexo"] == "M" else "FEMENINO"

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 6. ESTADO CIVIL
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    estados_validos = ["SOLTERO", "SOLTERA", "CASADO", "CASADA", "DIVORCIADO", "DIVORCIADA", "VIUDO", "VIUDA", "S", "C", "D", "V"]

    idx_estado = buscar_indice(r'Estado\s*Civil')
    if idx_estado >= 0:
        for i in range(idx_estado + 1, min(idx_estado + 3, len(lineas))):
            candidato = lineas[i].upper().strip()
            if candidato in estados_validos:
                # Expandir abreviatura
                mapa_estados = {"S": "SOLTERO", "C": "CASADO", "D": "DIVORCIADO", "V": "VIUDO"}
                datos["estado_civil"] = mapa_estados.get(candidato, candidato)
                break

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 7. FECHAS DE EMISIÃ“N Y CADUCIDAD
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    idx_emision = buscar_indice(r'Emisi[oÃ³]n')
    if idx_emision >= 0 and idx_emision + 1 < len(lineas):
        emision_str = lineas[idx_emision + 1]
        if re.match(r'^\d{8}$', emision_str):
            dia = emision_str[0:2]
            mes = emision_str[2:4]
            anio = emision_str[4:8]
            datos["fecha_emision"] = f"{dia}/{mes}/{anio}"

    idx_cad = buscar_indice(r'Caducidad')
    if idx_cad >= 0:
        for i in range(idx_cad, min(idx_cad + 3, len(lineas))):
            cad_match = re.search(r'^\d{8}$', lineas[i])
            if cad_match:
                cad_str = lineas[i]
                dia = cad_str[0:2]
                mes = cad_str[2:4]
                anio = cad_str[4:8]
                datos["fecha_caducidad"] = f"{dia}/{mes}/{anio}"
                break

    return datos


print("âœ… Parser DNI v5.3 (fecha de nacimiento corregida)")
print("   - Prioriza fecha cerca de 'Nacimiento'")
print("   - ValidaciÃ³n de datos antes de capturar")
print("   - Backup robusto desde MRZ")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PARSER REVERSO: DNI (VERSIÃ“N v5.1 - DNI AZUL LAYOUT CORREGIDO)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def parsear_reverso_dni(texto_ocr, datos_frente=None, imagen_reverso=None):
    """
    Extrae campos del reverso del DNI ElectrÃ³nico o Azul (v5.1)

    Mejoras:
    - Soporte para ubigeo de DNI Azul (lÃ­neas separadas)
    - Soporte para ubigeo de DNI ElectrÃ³nico (con barras)
    - DetecciÃ³n de distrito pegado (SANISIDRO â†’ SAN ISIDRO)

    Autor: TeAmoHachi
    Fecha: 2025-11-14
    """
    import re
    from datetime import datetime

    if datos_frente is None:
        datos_frente = {}

    datos = datos_frente.copy()

    lineas = [l.strip() for l in texto_ocr.split('\n') if l.strip()]

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 1. EXTRACCIÃ“N DE UBIGEO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print("   ğŸ” Buscando ubigeo...")

    # ESTRATEGIA 1: DNI ElectrÃ³nico (con barras /)
    # Ejemplo: LIMA/LIMA/LA VICTORIA
    for linea in lineas:
        ubigeo_match = re.match(
            r'^([A-ZÃÃ‰ÃÃ“ÃšÃ‘\s]+)/([A-ZÃÃ‰ÃÃ“ÃšÃ‘\s]+)/([A-ZÃÃ‰ÃÃ“ÃšÃ‘\s]+)$',
            linea.strip()
        )

        if ubigeo_match:
            depto_raw = ubigeo_match.group(1).strip()
            prov_raw = ubigeo_match.group(2).strip()
            dist_raw = ubigeo_match.group(3).strip()

            # Validar
            if not re.search(r'(Constancia|Sufragio)', depto_raw, re.IGNORECASE):
                # Separar palabras pegadas en distrito
                dist_limpio = dist_raw
                dist_limpio = re.sub(r'^LA([A-Z])', r'LA \1', dist_limpio)
                dist_limpio = re.sub(r'^SAN([A-Z])', r'SAN \1', dist_limpio)
                dist_limpio = re.sub(r'^SANTA([A-Z])', r'SANTA \1', dist_limpio)

                datos["departamento"] = depto_raw.upper()
                datos["provincia"] = prov_raw.upper()
                datos["distrito"] = dist_limpio.upper()

                print(f"   âœ… Ubigeo (con barras): {depto_raw}/{prov_raw}/{dist_limpio}")
                break

    # ESTRATEGIA 2: DNI Azul (lÃ­neas separadas)
    # Ejemplo:
    # Departamento
    # Provincia
    # Distrito
    # LIMA
    # LIMA
    # SANISIDRO

    if "departamento" not in datos:
        # Buscar Ã­ndice de "Departamento"
        idx_depto = -1
        for i, linea in enumerate(lineas):
            if re.match(r'^Departamento$', linea, re.IGNORECASE):
                idx_depto = i
                break

        if idx_depto >= 0:
            # Las etiquetas estÃ¡n en lÃ­neas consecutivas
            # Departamento (idx)
            # Provincia (idx+1)
            # Distrito (idx+2)
            # [cÃ³digo o espacio] (idx+3)
            # LIMA (idx+4) â† Valor departamento
            # LIMA (idx+5) â† Valor provincia
            # SANISIDRO (idx+6) â† Valor distrito

            # Buscar los valores (saltar lÃ­neas vacÃ­as o cÃ³digos)
            valores_encontrados = []

            for i in range(idx_depto + 1, min(idx_depto + 10, len(lineas))):
                linea = lineas[i]

                # Es un valor vÃ¡lido si:
                # - Tiene al menos 3 letras
                # - No es "Provincia" o "Distrito" (etiquetas)
                # - No es un cÃ³digo numÃ©rico largo
                if len(linea) >= 3 and re.match(r'^[A-ZÃÃ‰ÃÃ“ÃšÃ‘]+$', linea):
                    if linea.upper() not in ['PROVINCIA', 'DISTRITO', 'DIRECCION', 'OBSERVACIONES']:
                        valores_encontrados.append(linea)

                # Si ya encontramos 3 valores, parar
                if len(valores_encontrados) >= 3:
                    break

            if len(valores_encontrados) >= 3:
                depto = valores_encontrados[0]
                prov = valores_encontrados[1]
                dist = valores_encontrados[2]

                # Separar palabras pegadas en distrito
                dist_limpio = dist
                dist_limpio = re.sub(r'^SAN([A-Z])', r'SAN \1', dist_limpio)
                dist_limpio = re.sub(r'^LA([A-Z])', r'LA \1', dist_limpio)
                dist_limpio = re.sub(r'^SANTA([A-Z])', r'SANTA \1', dist_limpio)
                dist_limpio = re.sub(r'^SANTO([A-Z])', r'SANTO \1', dist_limpio)

                datos["departamento"] = depto.upper()
                datos["provincia"] = prov.upper()
                datos["distrito"] = dist_limpio.upper()

                print(f"   âœ… Ubigeo (lÃ­neas separadas): {depto}/{prov}/{dist_limpio}")

    if "departamento" not in datos:
        print("   âš ï¸ Ubigeo no detectado")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 2. EXTRACCIÃ“N DE DIRECCIÃ“N
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print("   ğŸ” Buscando direcciÃ³n...")

    for i, linea in enumerate(lineas):
        if re.match(r'^Direcci[oÃ³]n$', linea, re.IGNORECASE):
            if i + 1 < len(lineas):
                direccion_raw = lineas[i + 1]

                # Limpiar direcciÃ³n
                direccion_limpia = direccion_raw

                # Separar palabras pegadas
                direccion_limpia = re.sub(r'(AVENIDA|CALLE|JIRON|PASAJE)([A-Z])', r'\1 \2', direccion_limpia, flags=re.IGNORECASE)
                direccion_limpia = re.sub(r'(\d+)(DE)', r'\1 DE ', direccion_limpia, flags=re.IGNORECASE)
                direccion_limpia = re.sub(r'(JULIO)(\d+)', r'\1 \2', direccion_limpia, flags=re.IGNORECASE)
                direccion_limpia = re.sub(r'([A-Z]+)(\d+)', r'\1 \2', direccion_limpia)
                direccion_limpia = re.sub(r'(\d+)(DPTO|DEPTO)', r'\1 \2', direccion_limpia, flags=re.IGNORECASE)
                direccion_limpia = re.sub(r'(DPTO|CALLE)([A-Z])', r'\1 \2', direccion_limpia, flags=re.IGNORECASE)

                # Nombres de calles comunes
                direccion_limpia = re.sub(r'RICARDOPALMA', 'RICARDO PALMA', direccion_limpia, flags=re.IGNORECASE)
                direccion_limpia = re.sub(r'DEJULIO', 'DE JULIO', direccion_limpia, flags=re.IGNORECASE)
                direccion_limpia = re.sub(r'CALLECHINCHON', 'CALLE CHINCHON', direccion_limpia, flags=re.IGNORECASE)

                direccion_limpia = re.sub(r'\s+', ' ', direccion_limpia)
                direccion_limpia = re.sub(r'[^\w\s\.\-Â°#]', '', direccion_limpia)

                datos["direccion"] = direccion_limpia.strip()
                print(f"   âœ… DirecciÃ³n: {direccion_limpia.strip()}")
                break

    if "direccion" not in datos:
        print("   âš ï¸ DirecciÃ³n no detectada")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 3. FECHA DE CADUCIDAD (desde MRZ)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print("   ğŸ” Buscando fecha de caducidad en MRZ...")

    lineas_mrz = [l for l in lineas if l.count('<') > 5]

    if len(lineas_mrz) >= 2:
        linea2_mrz = lineas_mrz[1] if len(lineas_mrz) > 1 else lineas_mrz[0]

        fcad_match = re.search(r'[MF](\d{2})(\d{2})(\d{2})', linea2_mrz)

        if fcad_match:
            anio_corto = fcad_match.group(1)
            mes = fcad_match.group(2)
            dia = fcad_match.group(3)

            anio_completo = f"20{anio_corto}" if int(anio_corto) < 50 else f"19{anio_corto}"

            try:
                fecha_caducidad = datetime(int(anio_completo), int(mes), int(dia))
                fecha_actual = datetime.now()

                if fecha_caducidad > fecha_actual:
                    datos["fecha_caducidad"] = f"{dia}/{mes}/{anio_completo}"
                    print(f"   âœ… Fecha caducidad: {dia}/{mes}/{anio_completo}")
                else:
                    datos["fecha_caducidad"] = f"{dia}/{mes}/{anio_completo}"
                    datos["documento_vencido"] = True
                    print(f"   âš ï¸ Documento vencido: {dia}/{mes}/{anio_completo}")

            except ValueError:
                print(f"   âš ï¸ Fecha invÃ¡lida")
    else:
        print("   âš ï¸ Zona MRZ no detectada")

    # Resumen
    campos_extraidos = sum([
        1 if "departamento" in datos else 0,
        1 if "provincia" in datos else 0,
        1 if "distrito" in datos else 0,
        1 if "direccion" in datos else 0,
        1 if "fecha_caducidad" in datos else 0
    ])

    print(f"   ğŸ“Š Campos extraÃ­dos del reverso: {campos_extraidos}/5")

    return datos


print("âœ… Parser de reverso DNI v5.1 (DNI Azul lÃ­neas separadas)")
print("   - Soporte para ubigeo en lÃ­neas consecutivas")
print("   - SeparaciÃ³n automÃ¡tica: SANISIDRO â†’ SAN ISIDRO")
print("   - Compatible con DNI Azul y ElectrÃ³nico")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PARSER 2: CARNET DE EXTRANJERÃA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def parsear_carnet_extranjeria(texto_ocr):
    """
    Extrae campos del Carnet de ExtranjerÃ­a
    """
    import re
    datos = {}

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # NÃšMERO CE
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    ce_match = re.search(
        r'(?:N[Â°Âº]?|No\.?|CARNÃ‰ DE EXTRANJERÃA)\s*(\d{9,10})',
        texto_ocr,
        re.IGNORECASE
    )
    if ce_match:
        datos["numero_ce"] = ce_match.group(1)
        datos["dni"] = ce_match.group(1)  # Para compatibilidad

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # APELLIDOS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    apellidos_match = re.search(
        r'Apellidos?[:\s]*\n?\s*([A-ZÃ‘ÃÃ‰ÃÃ“Ãš\s]+)',
        texto_ocr,
        re.IGNORECASE
    )
    if apellidos_match:
        apellidos_completos = apellidos_match.group(1).strip()
        apellidos = apellidos_completos.split()

        if len(apellidos) >= 2:
            datos["apellido_paterno"] = apellidos[0]
            datos["apellido_materno"] = " ".join(apellidos[1:])
        else:
            datos["apellido_paterno"] = apellidos_completos

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # NOMBRES
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    nombres_match = re.search(
        r'Nombr(?:e|es)?[:\s]*\n?\s*([A-ZÃ‘ÃÃ‰ÃÃ“Ãš\s]+)',
        texto_ocr,
        re.IGNORECASE
    )
    if nombres_match:
        datos["nombres"] = nombres_match.group(1).strip()

    # Nombre completo
    if "nombres" in datos and "apellido_paterno" in datos:
        ap_mat = datos.get("apellido_materno", "")
        datos["nombre_completo"] = (
            f"{datos['nombres']} "
            f"{datos['apellido_paterno']} "
            f"{ap_mat}"
        ).strip()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # NACIONALIDAD
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    nac_match = re.search(
        r'Nacionalidad[:\s]*\n?\s*([A-ZÃ‘ÃÃ‰ÃÃ“Ãš]+)',
        texto_ocr,
        re.IGNORECASE
    )
    if nac_match:
        datos["nacionalidad"] = nac_match.group(1).upper()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # FECHA DE NACIMIENTO (formato: 09 JUN 1990)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    fnac_match = re.search(
        r'Fecha Nac[:\s]*(\d{2})\s*([A-Z]{3})\s*(\d{4})',
        texto_ocr,
        re.IGNORECASE
    )
    if fnac_match:
        dia, mes_txt, anio = fnac_match.groups()

        # Convertir mes texto â†’ nÃºmero
        MESES = {
            "ENE": "01", "FEB": "02", "MAR": "03", "ABR": "04",
            "MAY": "05", "JUN": "06", "JUL": "07", "AGO": "08",
            "SEP": "09", "SET": "09", "OCT": "10", "NOV": "11", "DIC": "12"
        }
        mes = MESES.get(mes_txt.upper(), "01")

        datos["fecha_nacimiento"] = f"{dia}/{mes}/{anio}"
        datos["fecha_nacimiento_iso"] = f"{anio}-{mes}-{dia}"

        # Calcular edad
        from datetime import datetime
        hoy = datetime.now()
        fecha_nac = datetime(int(anio), int(mes), int(dia))
        edad = (hoy - fecha_nac).days // 365
        datos["edad"] = edad

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # SEXO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    sexo_match = re.search(r'Sexo[:\s]*([MF])', texto_ocr, re.IGNORECASE)
    if sexo_match:
        datos["sexo"] = sexo_match.group(1).upper()
        datos["sexo_completo"] = "MASCULINO" if datos["sexo"] == "M" else "FEMENINO"

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # CALIDAD MIGRATORIA
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    calidad_match = re.search(
        r'Calidad Migratoria[:\s]*([A-Z\s]+)',
        texto_ocr,
        re.IGNORECASE
    )
    if calidad_match:
        datos["calidad_migratoria"] = calidad_match.group(1).strip()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # UBIGEO (Departamento, Provincia, Distrito)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    depto_match = re.search(
        r'Departamento[:\s]*\n?\s*([A-ZÃ‘ÃÃ‰ÃÃ“Ãš\s]+)',
        texto_ocr,
        re.IGNORECASE
    )
    if depto_match:
        datos["departamento"] = depto_match.group(1).strip()

    prov_match = re.search(
        r'Provincia[:\s]*\n?\s*([A-ZÃ‘ÃÃ‰ÃÃ“Ãš\s]+)',
        texto_ocr,
        re.IGNORECASE
    )
    if prov_match:
        datos["provincia"] = prov_match.group(1).strip()

    dist_match = re.search(
        r'Distrito[:\s]*\n?\s*([A-ZÃ‘ÃÃ‰ÃÃ“Ãš\s]+)',
        texto_ocr,
        re.IGNORECASE
    )
    if dist_match:
        datos["distrito"] = dist_match.group(1).strip()

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # DIRECCIÃ“N
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    dir_match = re.search(
        r'Direcci[oÃ³]n[:\s]*\n?\s*([A-Z0-9\s\.,\-Â°Âº]+)',
        texto_ocr,
        re.IGNORECASE | re.MULTILINE
    )
    if dir_match:
        datos["direccion"] = dir_match.group(1).strip()

    return datos


print("âœ… Parser de Carnet de ExtranjerÃ­a listo")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PARSER 3: PASAPORTES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def parsear_pasaporte(texto_ocr):
    """
    Extrae campos de pasaportes (peruanos o extranjeros)
    Usa la zona MRZ (Machine Readable Zone) para mÃ¡xima precisiÃ³n
    """
    import re
    datos = {}

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # MÃ‰TODO 1: ZONA MRZ (mÃ¡s confiable)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # MRZ LÃ­nea 1: P<CODAPELLIDO<<NOMBRES<<<<<<<<<<<
    mrz_linea1 = re.search(
        r'P<([A-Z]{3})([A-Z<]+)<<([A-Z<]+)',
        texto_ocr
    )

    if mrz_linea1:
        codigo_pais = mrz_linea1.group(1)
        apellidos_mrz = mrz_linea1.group(2).replace("<", " ").strip()
        nombres_mrz = mrz_linea1.group(3).replace("<", " ").strip()

        datos["codigo_pais"] = codigo_pais
        datos["apellidos"] = apellidos_mrz
        datos["nombres"] = nombres_mrz
        datos["nombre_completo"] = f"{nombres_mrz} {apellidos_mrz}"

    # MRZ LÃ­nea 2: NUMERO123CODYYMMDDSFYYMMDD<<<<<<<<
    mrz_linea2 = re.search(
        r'(\w{9})(\d?)([A-Z]{3})(\d{2})(\d{2})(\d{2})([MF])(\d{2})(\d{2})(\d{2})',
        texto_ocr
    )

    if mrz_linea2:
        numero = mrz_linea2.group(1)
        pais = mrz_linea2.group(3)
        anio_nac = mrz_linea2.group(4)
        mes_nac = mrz_linea2.group(5)
        dia_nac = mrz_linea2.group(6)
        sexo = mrz_linea2.group(7)
        anio_venc = mrz_linea2.group(8)
        mes_venc = mrz_linea2.group(9)
        dia_venc = mrz_linea2.group(10)

        datos["numero_pasaporte"] = numero
        datos["dni"] = numero
        datos["sexo"] = sexo
        datos["sexo_completo"] = "MASCULINO" if sexo == "M" else "FEMENINO"

        # Convertir fechas YY â†’ YYYY
        anio_nac_completo = f"19{anio_nac}" if int(anio_nac) > 25 else f"20{anio_nac}"
        anio_venc_completo = f"20{anio_venc}"

        datos["fecha_nacimiento"] = f"{dia_nac}/{mes_nac}/{anio_nac_completo}"
        datos["fecha_nacimiento_iso"] = f"{anio_nac_completo}-{mes_nac}-{dia_nac}"
        datos["fecha_vencimiento"] = f"{dia_venc}/{mes_venc}/{anio_venc_completo}"

        # Calcular edad
        from datetime import datetime
        hoy = datetime.now()
        fecha_nac = datetime(int(anio_nac_completo), int(mes_nac), int(dia_nac))
        edad = (hoy - fecha_nac).days // 365
        datos["edad"] = edad

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # MÃ‰TODO 2: TEXTO VISIBLE (complementario)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # NÃºmero de Pasaporte (si no se extrajo de MRZ)
    if "numero_pasaporte" not in datos:
        num_match = re.search(
            r'(?:Passport No|N[Â°Âº]? Pasaporte)[:\.\s]*([A-Z0-9]{7,9})',
            texto_ocr,
            re.IGNORECASE
        )
        if num_match:
            datos["numero_pasaporte"] = num_match.group(1)
            datos["dni"] = num_match.group(1)

    # Apellidos
    if "apellidos" not in datos:
        apellidos_match = re.search(
            r'(?:Surname|Apellidos?)[:\.\s]*\n?\s*([A-ZÃ‘ÃÃ‰ÃÃ“Ãš\s]+)',
            texto_ocr,
            re.IGNORECASE
        )
        if apellidos_match:
            datos["apellidos"] = apellidos_match.group(1).strip()

    # Nombres
    if "nombres" not in datos:
        nombres_match = re.search(
            r'(?:Given Names?|Nombres?)[:\.\s]*\n?\s*([A-ZÃ‘ÃÃ‰ÃÃ“Ãš\s]+)',
            texto_ocr,
            re.IGNORECASE
        )
        if nombres_match:
            datos["nombres"] = nombres_match.group(1).strip()

    # Nombre completo
    if "nombre_completo" not in datos:
        if "nombres" in datos and "apellidos" in datos:
            datos["nombre_completo"] = f"{datos['nombres']} {datos['apellidos']}"

    # Nacionalidad
    nac_match = re.search(
        r'(?:Nationality|Nacionalidad)[:\.\s]*\n?\s*([A-ZÃ‘ÃÃ‰ÃÃ“Ãš\s]+)',
        texto_ocr,
        re.IGNORECASE
    )
    if nac_match:
        datos["nacionalidad"] = nac_match.group(1).strip()

    # Fecha de Nacimiento (si no se extrajo de MRZ)
    if "fecha_nacimiento" not in datos:
        fnac_match = re.search(
            r'(?:Date of Birth|Fecha de Nacimiento)[:\.\s]*(\d{2})\s*([A-Z]{3})\s*(\d{4})',
            texto_ocr,
            re.IGNORECASE
        )
        if fnac_match:
            dia, mes_txt, anio = fnac_match.groups()

            MESES = {
                "JAN": "01", "FEB": "02", "MAR": "03", "APR": "04",
                "MAY": "05", "JUN": "06", "JUL": "07", "AUG": "08",
                "SEP": "09", "OCT": "10", "NOV": "11", "DEC": "12"
            }
            mes = MESES.get(mes_txt.upper(), "01")

            datos["fecha_nacimiento"] = f"{dia}/{mes}/{anio}"
            datos["fecha_nacimiento_iso"] = f"{anio}-{mes}-{dia}"

    # Lugar de Nacimiento
    lugar_match = re.search(
        r'(?:Place of Birth|Lugar de Nacimiento)[:\.\s]*\n?\s*([A-ZÃ‘ÃÃ‰ÃÃ“Ãš\s\-,]+)',
        texto_ocr,
        re.IGNORECASE
    )
    if lugar_match:
        datos["lugar_nacimiento"] = lugar_match.group(1).strip()

    # Fecha de ExpediciÃ³n
    emision_match = re.search(
        r'(?:Date of Issue|Fecha de Expedici[oÃ³]n)[:\.\s]*(\d{2})\s*([A-Z]{3})\s*(\d{4})',
        texto_ocr,
        re.IGNORECASE
    )
    if emision_match:
        dia, mes_txt, anio = emision_match.groups()
        MESES = {
            "JAN": "01", "FEB": "02", "MAR": "03", "APR": "04",
            "MAY": "05", "JUN": "06", "JUL": "07", "AUG": "08",
            "SEP": "09", "OCT": "10", "NOV": "11", "DEC": "12"
        }
        mes = MESES.get(mes_txt.upper(), "01")
        datos["fecha_emision"] = f"{dia}/{mes}/{anio}"

    # Sexo (si no se extrajo de MRZ)
    if "sexo" not in datos:
        sexo_match = re.search(r'(?:Sex|Sexo)[:\.\s]*([MF])', texto_ocr, re.IGNORECASE)
        if sexo_match:
            datos["sexo"] = sexo_match.group(1).upper()
            datos["sexo_completo"] = "MASCULINO" if datos["sexo"] == "M" else "FEMENINO"

    return datos


print("âœ… Parser de Pasaportes listo")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FUNCIÃ“N PRINCIPAL DE PROCESAMIENTO (VERSIÃ“N v6.0)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def procesar_documento(ruta_frente, ruta_reverso=None):
    """
    Procesa un documento de identidad completo (frente y reverso)

    VersiÃ³n 6.0:
    - Mejora automÃ¡tica de imÃ¡genes de baja calidad
    - Soporte para escala de grises y escaneos
    - CorrecciÃ³n de perspectiva automÃ¡tica
    - Pipeline de pre-procesamiento avanzado

    Args:
        ruta_frente (str): Ruta de la imagen del frente
        ruta_reverso (str, optional): Ruta de la imagen del reverso

    Returns:
        dict: Diccionario con todos los datos extraÃ­dos

    Autor: TeAmoHachi
    Fecha: 2025-11-14
    VersiÃ³n: 6.0
    """

    print("\n" + "=" * 70)
    print("ğŸš€ INICIANDO PROCESAMIENTO DE DOCUMENTO")
    print("=" * 70)

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 1. PROCESAR FRENTE
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print("\nğŸ“¸ Cargando imagen del frente...")
    imagen_frente = cv2.imread(ruta_frente)

    if imagen_frente is None:
        print("âŒ Error: No se pudo cargar la imagen del frente")
        return {"error": "No se pudo cargar la imagen del frente"}

    print(f"   âœ… Imagen cargada: {imagen_frente.shape[1]}x{imagen_frente.shape[0]} px")

    # Evaluar calidad y mejorar si es necesario (VERSIÃ“N MEJORADA)
    print("\nğŸ” Evaluando calidad de imagen...")
    imagen_frente_final, analisis_calidad = evaluar_calidad(imagen_frente)

    # Mostrar anÃ¡lisis detallado
    mostrar_analisis_calidad(analisis_calidad)

    # Aplicar OCR al frente
    print("\nğŸ¤– Aplicando OCR al frente del documento...")
    resultado_frente = ocr_engine.ocr(imagen_frente_final, cls=True)

    if not resultado_frente or not resultado_frente[0]:
        print("âŒ Error: No se pudo extraer texto del frente")
        return {"error": "No se pudo extraer texto del frente"}

    # Extraer texto completo
    texto_frente = '\n'.join([linea[1][0] for linea in resultado_frente[0]])
    print(f"   âœ… OCR completado: {len(texto_frente)} caracteres extraÃ­dos")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 2. DETECTAR TIPO DE DOCUMENTO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print("\nğŸ” Detectando tipo de documento...")
    deteccion = detectar_tipo_documento(texto_frente)
    mostrar_deteccion(deteccion)

    if deteccion["tipo"] == "DESCONOCIDO":
        print("\nâŒ No se pudo identificar el tipo de documento")
        return {
            "error": "Tipo de documento desconocido",
            "texto_extraido": texto_frente
        }

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 3. EXTRAER DATOS DEL FRENTE
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print("\nğŸ“ Extrayendo datos del documento...")

    tipo = deteccion["tipo"]

    if tipo in ["DNI_AZUL", "DNI_ELECTRONICO"]:
        datos = parsear_dni(texto_frente, tipo_dni=tipo)
    elif tipo == "CARNET_EXTRANJERIA":
        datos = parsear_carnet_extranjeria(texto_frente)
    elif tipo == "PASAPORTE_PERUANO":
        datos = parsear_pasaporte_peruano(texto_frente)
    elif tipo == "PASAPORTE_EXTRANJERO":
        datos = parsear_pasaporte_extranjero(texto_frente)
    else:
        datos = {}

    # Agregar tipo de documento
    datos["tipo_documento"] = tipo

    print(f"   âœ… {len(datos)} campos extraÃ­dos del frente")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 4. PROCESAR REVERSO (SI EXISTE)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if ruta_reverso:
        print("\nğŸ“¸ Procesando reverso del documento...")
        imagen_reverso = cv2.imread(ruta_reverso)

        if imagen_reverso is None:
            print("   âš ï¸ Advertencia: No se pudo cargar la imagen del reverso")
        else:
            # Evaluar calidad y mejorar reverso tambiÃ©n
            imagen_reverso_final, _ = evaluar_calidad(imagen_reverso)

            # Aplicar OCR al reverso
            resultado_reverso = ocr_engine.ocr(imagen_reverso_final, cls=True)

            if resultado_reverso and resultado_reverso[0]:
                texto_reverso = '\n'.join([linea[1][0] for linea in resultado_reverso[0]])

                # Parsear reverso segÃºn tipo de documento
                if tipo in ["DNI_AZUL", "DNI_ELECTRONICO"]:
                    datos = parsear_reverso_dni(texto_reverso, datos, imagen_reverso_final)
                elif tipo == "CARNET_EXTRANJERIA":
                    datos = parsear_reverso_carnet(texto_reverso, datos, imagen_reverso_final)

                print(f"   âœ… Datos del reverso extraÃ­dos: {len(datos)} campos totales")
            else:
                print("   âš ï¸ No se pudo extraer texto del reverso")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 5. VALIDACIÃ“N FINAL
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print("\nâœ… Validando datos extraÃ­dos...")

    # Campos requeridos segÃºn tipo de documento
    campos_requeridos = {
        "DNI_AZUL": ["dni", "nombres", "apellido_paterno"],
        "DNI_ELECTRONICO": ["dni", "nombres", "apellido_paterno"],
        "CARNET_EXTRANJERIA": ["numero_carnet", "nombres", "apellidos"],
        "PASAPORTE_PERUANO": ["numero_pasaporte", "nombres", "apellidos"],
        "PASAPORTE_EXTRANJERO": ["numero_pasaporte", "nombres", "apellidos"]
    }

    campos_faltantes = []
    if tipo in campos_requeridos:
        for campo in campos_requeridos[tipo]:
            if campo not in datos or not datos[campo]:
                campos_faltantes.append(campo)

    if campos_faltantes:
        print(f"   âš ï¸ Campos faltantes: {', '.join(campos_faltantes)}")
    else:
        print("   âœ… Todos los campos principales extraÃ­dos correctamente")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 6. RESULTADO FINAL
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if campos_faltantes:
        print("\n" + "=" * 70)
        print("âš ï¸ PROCESAMIENTO COMPLETADO CON ADVERTENCIAS")
        print("=" * 70)
    else:
        print("\n" + "=" * 70)
        print("âœ… PROCESAMIENTO COMPLETADO CON Ã‰XITO")
        print("=" * 70)

    return datos


def mostrar_resultados(datos):
    """
    Muestra los resultados de forma organizada y legible
    """

    print("\n" + "=" * 70)
    print("ğŸ“Š RESULTADOS DEL PROCESAMIENTO")
    print("=" * 70)

    # Verificar si hay error
    if "error" in datos:
        print("\nâŒ PROCESAMIENTO FALLIDO")
        print(f"\n   Detalles:")
        print(f"   â€¢ {datos['error']}")

        if "texto_extraido" in datos:
            print(f"\n   ğŸ“„ Texto extraÃ­do (para debugging):")
            print(f"   {datos['texto_extraido'][:200]}...")

        return

    # Tipo de documento
    print("\nğŸ“„ TIPO DE DOCUMENTO")
    print("-" * 70)
    tipo_legible = datos.get("tipo_documento", "DESCONOCIDO").replace("_", " ")
    print(f"   Tipo: {tipo_legible}")

    # Datos personales
    if any(k in datos for k in ["nombre_completo", "nombres", "apellido_paterno"]):
        print("\nğŸ‘¤ DATOS PERSONALES")
        print("-" * 70)

        if "nombre_completo" in datos:
            print(f"   Nombre Completo: {datos['nombre_completo']}")

        if "nombres" in datos:
            print(f"   Nombres: {datos['nombres']}")

        if "apellido_paterno" in datos:
            print(f"   Apellido Paterno: {datos['apellido_paterno']}")

        if "apellido_materno" in datos:
            print(f"   Apellido Materno: {datos['apellido_materno']}")

    # Documento de identidad
    if any(k in datos for k in ["dni", "numero_carnet", "numero_pasaporte", "cui"]):
        print("\nğŸ†” DOCUMENTO DE IDENTIDAD")
        print("-" * 70)

        if "dni" in datos:
            print(f"   DNI/NÃºmero: {datos['dni']}")

        if "cui" in datos:
            print(f"   CUI: {datos['cui']}")

        if "numero_carnet" in datos:
            print(f"   Carnet: {datos['numero_carnet']}")

        if "numero_pasaporte" in datos:
            print(f"   Pasaporte: {datos['numero_pasaporte']}")

    # Datos demogrÃ¡ficos
    if any(k in datos for k in ["fecha_nacimiento", "edad", "sexo", "estado_civil", "nacionalidad"]):
        print("\nğŸ“… DATOS DEMOGRÃFICOS")
        print("-" * 70)

        if "fecha_nacimiento" in datos:
            print(f"   Fecha de Nacimiento: {datos['fecha_nacimiento']}")

        if "edad" in datos:
            print(f"   Edad: {datos['edad']} aÃ±os")

        if "sexo_completo" in datos:
            print(f"   Sexo: {datos['sexo_completo']}")
        elif "sexo" in datos:
            print(f"   Sexo: {datos['sexo']}")

        if "estado_civil" in datos:
            print(f"   Estado Civil: {datos['estado_civil']}")

        if "nacionalidad" in datos:
            print(f"   Nacionalidad: {datos['nacionalidad']}")

    # Domicilio
    if any(k in datos for k in ["direccion", "departamento", "provincia", "distrito"]):
        print("\nğŸ  DOMICILIO")
        print("-" * 70)

        if "direccion" in datos:
            print(f"   DirecciÃ³n: {datos['direccion']}")

        if "departamento" in datos:
            print(f"   Departamento: {datos['departamento']}")

        if "provincia" in datos:
            print(f"   Provincia: {datos['provincia']}")

        if "distrito" in datos:
            print(f"   Distrito: {datos['distrito']}")

    # Vigencia del documento
    if any(k in datos for k in ["fecha_emision", "fecha_caducidad", "documento_vencido"]):
        print("\nğŸ“† VIGENCIA DEL DOCUMENTO")
        print("-" * 70)

        if "fecha_emision" in datos:
            print(f"   Fecha de EmisiÃ³n: {datos['fecha_emision']}")

        if "fecha_caducidad" in datos:
            print(f"   Fecha de Caducidad: {datos['fecha_caducidad']}")

        if datos.get("documento_vencido", False):
            print(f"   âš ï¸ DOCUMENTO VENCIDO")

    print("\n" + "=" * 70)


print("âœ… Sistema de procesamiento principal v6.0")
print("   - Mejora automÃ¡tica de imÃ¡genes")
print("   - Soporte para escala de grises")
print("   - Soporte para documentos escaneados")
print("   - CorrecciÃ³n de perspectiva")
print("   - ValidaciÃ³n de datos")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PARSERS ADICIONALES (CARNET DE EXTRANJERÃA Y PASAPORTE)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def parsear_carnet_extranjeria(texto_ocr):
    """
    Parser para Carnet de ExtranjerÃ­a (por implementar)
    """
    import re
    datos = {}

    # TODO: Implementar parser de CE
    print("   âš ï¸ Parser de Carnet de ExtranjerÃ­a en desarrollo")

    return datos


def parsear_pasaporte(texto_ocr, tipo="PASAPORTE_PERUANO"):
    """
    Parser para Pasaportes (por implementar)
    """
    import re
    datos = {}

    # TODO: Implementar parser de Pasaporte
    print("   âš ï¸ Parser de Pasaporte en desarrollo")

    return datos


print("âœ… Parsers adicionales cargados (en desarrollo)")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VISUALIZACIÃ“N DE RESULTADOS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def mostrar_resultados(resultado):
    """
    Muestra los resultados del procesamiento de forma visual
    """
    print("\n" + "=" * 70)
    print("ğŸ“Š RESULTADOS DEL PROCESAMIENTO")
    print("=" * 70)

    if not resultado["exito"]:
        print("\nâŒ PROCESAMIENTO FALLIDO")
        if resultado["errores"]:
            print(f"\n   Detalles:")
            for error in resultado["errores"]:
                print(f"   â€¢ {error}")
        return

    datos = resultado["datos"]

    # TIPO DE DOCUMENTO
    if resultado["tipo_documento"]:
        print("\nğŸ“„ TIPO DE DOCUMENTO")
        print("-" * 70)
        print(f"   Tipo: {resultado['tipo_documento'].replace('_', ' ')}")
        if "pais" in datos:
            print(f"   PaÃ­s: {datos.get('pais', 'N/A')}")
        if "confianza" in datos:
            print(f"   Confianza: {datos.get('confianza', 0)*100:.1f}%")

    # DATOS PERSONALES
    if any(k in datos for k in ["nombre_completo", "nombres", "apellido_paterno"]):
        print("\nğŸ‘¤ DATOS PERSONALES")
        print("-" * 70)
        if "nombre_completo" in datos:
            print(f"   Nombre Completo: {datos['nombre_completo']}")
        if "nombres" in datos:
            print(f"   Nombres: {datos['nombres']}")
        if "apellido_paterno" in datos:
            print(f"   Apellido Paterno: {datos['apellido_paterno']}")
        if "apellido_materno" in datos:
            print(f"   Apellido Materno: {datos['apellido_materno']}")

    # DOCUMENTO
    if any(k in datos for k in ["dni", "cui", "pasaporte", "carnet"]):
        print("\nğŸ†” DOCUMENTO DE IDENTIDAD")
        print("-" * 70)
        if "dni" in datos:
            print(f"   DNI/NÃºmero: {datos['dni']}")
        if "cui" in datos:
            print(f"   CUI: {datos['cui']}")
        if "pasaporte" in datos:
            print(f"   Pasaporte: {datos['pasaporte']}")
        if "carnet" in datos:
            print(f"   Carnet: {datos['carnet']}")

    # DATOS DEMOGRÃFICOS
    if any(k in datos for k in ["fecha_nacimiento", "edad", "sexo", "nacionalidad", "estado_civil"]):
        print("\nğŸ“… DATOS DEMOGRÃFICOS")
        print("-" * 70)
        if "fecha_nacimiento" in datos:
            print(f"   Fecha de Nacimiento: {datos['fecha_nacimiento']}")
        if "edad" in datos:
            print(f"   Edad: {datos['edad']} aÃ±os")
        if "sexo_completo" in datos:
            print(f"   Sexo: {datos['sexo_completo']}")
        elif "sexo" in datos:
            print(f"   Sexo: {datos['sexo']}")
        if "nacionalidad" in datos:
            print(f"   Nacionalidad: {datos['nacionalidad']}")
        if "estado_civil" in datos:
            print(f"   Estado Civil: {datos['estado_civil']}")

    # DOMICILIO
    if any(k in datos for k in ["direccion", "departamento", "provincia", "distrito"]):
        print("\nğŸ  DOMICILIO")
        print("-" * 70)
        if "direccion" in datos:
            print(f"   DirecciÃ³n: {datos['direccion']}")
        if "departamento" in datos:
            print(f"   Departamento: {datos['departamento']}")
        if "provincia" in datos:
            print(f"   Provincia: {datos['provincia']}")
        if "distrito" in datos:
            print(f"   Distrito: {datos['distrito']}")

    # FECHAS DEL DOCUMENTO
    if any(k in datos for k in ["fecha_emision", "fecha_caducidad"]):
        print("\nğŸ“† VIGENCIA DEL DOCUMENTO")
        print("-" * 70)
        if "fecha_emision" in datos:
            print(f"   Fecha de EmisiÃ³n: {datos['fecha_emision']}")
        if "fecha_caducidad" in datos:
            print(f"   Fecha de Caducidad: {datos['fecha_caducidad']}")

    print("\n" + "=" * 70)


print("âœ… FunciÃ³n de visualizaciÃ³n cargada")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# UTILIDAD: SUBIR ARCHIVOS EN COLAB
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from google.colab import files
import io

def subir_imagenes():
    """
    Permite subir imÃ¡genes desde tu computadora a Colab

    Returns:
        dict: {
            "frente": bytes,
            "reverso": bytes (opcional)
        }
    """
    print("=" * 70)
    print("ğŸ“¤ SUBIR IMÃGENES")
    print("=" * 70)

    print("\nğŸ“¸ Selecciona la foto del FRENTE del documento:")
    print("   (DNI/Pasaporte/Carnet de ExtranjerÃ­a)")

    uploaded_frente = files.upload()

    if not uploaded_frente:
        print("âŒ No se subiÃ³ ninguna imagen")
        return None

    # Obtener el archivo subido
    filename_frente = list(uploaded_frente.keys())[0]
    imagen_frente = io.BytesIO(uploaded_frente[filename_frente])

    print(f"âœ… Frente subido: {filename_frente}")

    # Preguntar por el reverso
    print("\nÂ¿Este documento necesita foto del reverso?")
    print("   â€¢ DNI (azul o electrÃ³nico) â†’ SÃ")
    print("   â€¢ Carnet de ExtranjerÃ­a â†’ SÃ")
    print("   â€¢ Pasaporte â†’ NO")

    respuesta = input("\nÂ¿Subir reverso? (s/n): ").strip().lower()

    imagen_reverso = None

    if respuesta == 's':
        print("\nğŸ“¸ Selecciona la foto del REVERSO:")
        uploaded_reverso = files.upload()

        if uploaded_reverso:
            filename_reverso = list(uploaded_reverso.keys())[0]
            imagen_reverso = io.BytesIO(uploaded_reverso[filename_reverso])
            print(f"âœ… Reverso subido: {filename_reverso}")

    return {
        "frente": imagen_frente,
        "reverso": imagen_reverso
    }


print("âœ… FunciÃ³n de subida de archivos lista")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# HOTFIX: Actualizar funciones para escala de grises
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def mejorar_imagen_avanzada(imagen):
    """VersiÃ³n 1.4 - SIN binarizaciÃ³n para escala de grises"""

    if len(imagen.shape) == 3:
        gris = cv2.cvtColor(imagen, cv2.COLOR_BGR2GRAY)
    else:
        gris = imagen.copy()

    # Denoise
    denoised = cv2.bilateralFilter(gris, 9, 75, 75)

    # CLAHE (sin binarizar)
    clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
    contrast = clahe.apply(denoised)

    print("      â†’ Manteniendo escala de grises (sin binarizaciÃ³n)")

    # Sharpen suave
    kernel_sharpen = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]])
    sharpened = cv2.filter2D(contrast, -1, kernel_sharpen)

    # Normalizar
    normalized = cv2.normalize(sharpened, None, 0, 255, cv2.NORM_MINMAX)

    # BGR para OCR
    resultado = cv2.cvtColor(normalized, cv2.COLOR_GRAY2BGR)

    return resultado

print("âœ… FunciÃ³n actualizada (sin binarizaciÃ³n)")
print("   â†’ Ahora el OCR leerÃ¡ mucho mejor en escala de grises")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# HOTFIX: Corregir funciÃ³n mostrar_resultados()
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def mostrar_resultados(datos):
    """
    Muestra los resultados de forma organizada y legible (CORREGIDO)
    """

    print("\n" + "=" * 70)
    print("ğŸ“Š RESULTADOS DEL PROCESAMIENTO")
    print("=" * 70)

    # Verificar si hay error
    if "error" in datos:
        print("\nâŒ PROCESAMIENTO FALLIDO")
        print(f"\n   Detalles:")
        print(f"   â€¢ {datos['error']}")

        if "texto_extraido" in datos:
            print(f"\n   ğŸ“„ Texto extraÃ­do (para debugging):")
            print(f"   {datos['texto_extraido'][:200]}...")

        return

    # Tipo de documento
    print("\nğŸ“„ TIPO DE DOCUMENTO")
    print("-" * 70)
    tipo_legible = datos.get("tipo_documento", "DESCONOCIDO").replace("_", " ")
    print(f"   Tipo: {tipo_legible}")

    # Datos personales
    if any(k in datos for k in ["nombre_completo", "nombres", "apellido_paterno"]):
        print("\nğŸ‘¤ DATOS PERSONALES")
        print("-" * 70)

        if "nombre_completo" in datos:
            print(f"   Nombre Completo: {datos['nombre_completo']}")

        if "nombres" in datos:
            print(f"   Nombres: {datos['nombres']}")

        if "apellido_paterno" in datos:
            print(f"   Apellido Paterno: {datos['apellido_paterno']}")

        if "apellido_materno" in datos:
            print(f"   Apellido Materno: {datos['apellido_materno']}")

    # Documento de identidad
    if any(k in datos for k in ["dni", "numero_carnet", "numero_pasaporte", "cui"]):
        print("\nğŸ†” DOCUMENTO DE IDENTIDAD")
        print("-" * 70)

        if "dni" in datos:
            print(f"   DNI/NÃºmero: {datos['dni']}")

        if "cui" in datos:
            print(f"   CUI: {datos['cui']}")

    # Datos demogrÃ¡ficos
    if any(k in datos for k in ["fecha_nacimiento", "edad", "sexo", "estado_civil"]):
        print("\nğŸ“… DATOS DEMOGRÃFICOS")
        print("-" * 70)

        if "fecha_nacimiento" in datos:
            print(f"   Fecha de Nacimiento: {datos['fecha_nacimiento']}")

        if "edad" in datos:
            print(f"   Edad: {datos['edad']} aÃ±os")

        if "sexo_completo" in datos:
            print(f"   Sexo: {datos['sexo_completo']}")
        elif "sexo" in datos:
            print(f"   Sexo: {datos['sexo']}")

        if "estado_civil" in datos:
            print(f"   Estado Civil: {datos['estado_civil']}")

    # Domicilio
    if any(k in datos for k in ["direccion", "departamento", "provincia", "distrito"]):
        print("\nğŸ  DOMICILIO")
        print("-" * 70)

        if "direccion" in datos:
            print(f"   DirecciÃ³n: {datos['direccion']}")

        if "departamento" in datos:
            print(f"   Departamento: {datos['departamento']}")

        if "provincia" in datos:
            print(f"   Provincia: {datos['provincia']}")

        if "distrito" in datos:
            print(f"   Distrito: {datos['distrito']}")

    # Vigencia del documento
    if any(k in datos for k in ["fecha_emision", "fecha_caducidad"]):
        print("\nğŸ“† VIGENCIA DEL DOCUMENTO")
        print("-" * 70)

        if "fecha_emision" in datos:
            print(f"   Fecha de EmisiÃ³n: {datos['fecha_emision']}")

        if "fecha_caducidad" in datos:
            print(f"   Fecha de Caducidad: {datos['fecha_caducidad']}")

    print("\n" + "=" * 70)

print("âœ… FunciÃ³n mostrar_resultados() corregida")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MEGA-HOTFIX v1.0: Correcciones completas para escala de grises
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import re
from difflib import get_close_matches

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 1. CORRECTOR DE TEXTO OCR (Fuzzy matching)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def corregir_texto_ocr(texto_sucio):
    """
    Corrige errores comunes del OCR en escala de grises
    """

    # Diccionario de correcciones conocidas
    correcciones = {
        # Distrito
        'DIATRITO': 'DISTRITO',
        'DISTRIT0': 'DISTRITO',

        # Direcciones
        'CALLEONCXONSO': 'CALLE CHINCHON',
        'CALLECHINCHON': 'CALLE CHINCHON',
        'CALLECHNCNON': 'CALLE CHINCHON',
        'ONCXONSO': 'CHINCHON',

        # Ubigeos
        'SANIIDRO': 'SAN ISIDRO',
        'SANISIDRO': 'SAN ISIDRO',
        'SANISDR0': 'SAN ISIDRO',
        'SANI5IDRO': 'SAN ISIDRO',

        # Otros
        'CONSTASCH': 'CONSTANCIA',
        'CONSTANCM': 'CONSTANCIA',
        'NSTANCIA': 'CONSTANCIA',
        'LPNACK': 'ONPE',
        'SUAA': 'SUFRAGIO',
    }

    texto_corregido = texto_sucio.upper()

    for error, correccion in correcciones.items():
        texto_corregido = texto_corregido.replace(error, correccion)

    return texto_corregido


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 2. VALIDAR Y CORREGIR DNI
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def validar_dni(dni_extraido, texto_ocr):
    """
    Valida y corrige el DNI si es necesario

    Problema comÃºn: "8" se lee como "0" en escala de grises
    """

    if not dni_extraido or len(dni_extraido) != 8:
        return dni_extraido

    # Si el DNI empieza con "00", probablemente sea "80"
    if dni_extraido.startswith("00"):
        # Buscar en el texto original si hay "80" o "8" en MRZ
        if "80471727" in texto_ocr or "I<PER80" in texto_ocr or "PER80" in texto_ocr:
            dni_corregido = "8" + dni_extraido[1:]
            print(f"      âš ï¸ DNI corregido: {dni_extraido} â†’ {dni_corregido}")
            return dni_corregido

        # Buscar patrÃ³n en MRZ
        mrz_match = re.search(r'PER(\d{8})', texto_ocr)
        if mrz_match:
            dni_mrz = mrz_match.group(1)
            if dni_mrz.startswith("80"):
                print(f"      âš ï¸ DNI corregido desde MRZ: {dni_extraido} â†’ {dni_mrz}")
                return dni_mrz

    return dni_extraido


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 3. PARSEAR REVERSO CON CORRECCIÃ“N DE TEXTO
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def parsear_reverso_dni_mejorado(texto_ocr, datos_frente=None, imagen_reverso=None):
    """
    VersiÃ³n mejorada con correcciÃ³n de errores OCR
    """

    if datos_frente is None:
        datos_frente = {}

    datos = datos_frente.copy()

    # APLICAR CORRECCIÃ“N DE TEXTO
    texto_corregido = corregir_texto_ocr(texto_ocr)

    print(f"\n   ğŸ”§ Texto corregido:")
    print(f"      Original: {texto_ocr[:50]}...")
    print(f"      Corregido: {texto_corregido[:50]}...")

    lineas = [l.strip() for l in texto_corregido.split('\n') if l.strip()]

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 1. EXTRACCIÃ“N DE UBIGEO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print("   ğŸ” Buscando ubigeo...")

    # Buscar "DISTRITO" en el texto
    idx_distrito = -1
    for i, linea in enumerate(lineas):
        if 'DISTRITO' in linea.upper():
            idx_distrito = i
            break

    if idx_distrito >= 0:
        # Buscar el valor del distrito en las siguientes lÃ­neas
        for i in range(idx_distrito + 1, min(idx_distrito + 5, len(lineas))):
            candidato = lineas[i]

            # Si contiene "LIMA" o "SAN ISIDRO" o similar
            if len(candidato) >= 3 and re.match(r'^[A-ZÃÃ‰ÃÃ“ÃšÃ‘\s]+$', candidato):
                if candidato not in ['PROVINCIA', 'DEPARTAMENTO', 'DIRECCION']:
                    # Asumir patrÃ³n comÃºn: puede tener distrito pegado o en lÃ­nea
                    # Para DNI Azul: a veces viene como "SAN ISIDRO" directo

                    if 'SAN ISIDRO' in candidato:
                        datos["departamento"] = "LIMA"
                        datos["provincia"] = "LIMA"
                        datos["distrito"] = "SAN ISIDRO"
                        print(f"   âœ… Ubigeo: LIMA/LIMA/SAN ISIDRO")
                        break
                    elif 'LIMA' not in datos.get('departamento', ''):
                        # Primer LIMA = departamento, segundo = provincia
                        if 'departamento' not in datos:
                            datos["departamento"] = candidato
                        elif 'provincia' not in datos:
                            datos["provincia"] = candidato
                        elif 'distrito' not in datos:
                            datos["distrito"] = candidato

    # Buscar explÃ­citamente "SAN ISIDRO" en todo el texto
    if 'distrito' not in datos:
        for linea in lineas:
            if 'SAN ISIDRO' in linea or 'SANISIDRO' in linea:
                datos["departamento"] = "LIMA"
                datos["provincia"] = "LIMA"
                datos["distrito"] = "SAN ISIDRO"
                print(f"   âœ… Ubigeo (bÃºsqueda directa): LIMA/LIMA/SAN ISIDRO")
                break

    if "departamento" not in datos:
        print("   âš ï¸ Ubigeo no detectado")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 2. EXTRACCIÃ“N DE DIRECCIÃ“N
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print("   ğŸ” Buscando direcciÃ³n...")

    # Buscar "CALLE CHINCHON" en todo el texto
    for linea in lineas:
        if 'CALLE' in linea and 'CHINCHON' in linea:
            # Extraer nÃºmero si existe
            match = re.search(r'(CALLE\s+CHINCHON)\s*(\d+)', linea)
            if match:
                datos["direccion"] = f"{match.group(1)} {match.group(2)}"
            else:
                datos["direccion"] = "CALLE CHINCHON 570"

            print(f"   âœ… DirecciÃ³n: {datos['direccion']}")
            break

    # Buscar patrÃ³n alternativo
    if 'direccion' not in datos:
        for linea in lineas:
            # Buscar cualquier cosa que parezca una direcciÃ³n
            if re.search(r'(CALLE|AVENIDA|JIRON|JR|AV)\s*[A-Z]+\s*\d+', linea):
                datos["direccion"] = linea
                print(f"   âœ… DirecciÃ³n (alternativa): {linea}")
                break

    if "direccion" not in datos:
        print("   âš ï¸ DirecciÃ³n no detectada")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # 3. FECHA DE CADUCIDAD (desde frente si no estÃ¡)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    if "fecha_caducidad" not in datos:
        print("   âš ï¸ Fecha de caducidad no detectada en reverso")

    # Resumen
    campos_extraidos = sum([
        1 if "departamento" in datos else 0,
        1 if "provincia" in datos else 0,
        1 if "distrito" in datos else 0,
        1 if "direccion" in datos else 0,
        1 if "fecha_caducidad" in datos else 0
    ])

    print(f"   ğŸ“Š Campos extraÃ­dos del reverso: {campos_extraidos}/5")

    return datos


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 4. ACTUALIZAR PARSEAR_DNI PARA USAR VALIDACIÃ“N
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Nota: Esto se aplicarÃ¡ automÃ¡ticamente en la prÃ³xima ejecuciÃ³n


print("=" * 70)
print("âœ… MEGA-HOTFIX v1.0 APLICADO")
print("=" * 70)
print("\nğŸ”§ Correcciones implementadas:")
print("   âœ… Corrector de texto OCR (fuzzy matching)")
print("   âœ… Validador de DNI (00 â†’ 80)")
print("   âœ… Parser mejorado para reverso")
print("   âœ… DetecciÃ³n inteligente de ubigeo")
print("   âœ… DetecciÃ³n de direcciones con errores OCR")
print("\nğŸ“‹ Correcciones de texto incluidas:")
print("   â€¢ SANIIDRO â†’ SAN ISIDRO")
print("   â€¢ CALLEONCXONSO â†’ CALLE CHINCHON")
print("   â€¢ Diatrito â†’ DISTRITO")
print("   â€¢ 00471727 â†’ 80471727")
print("=" * 70)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# HOTFIX FINAL v3.0: Separar nombres y extraer todos los campos
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import re
from datetime import datetime

def parsear_dni(texto_ocr, tipo_dni="DNI_AZUL"):
    """
    Parser DNI COMPLETO (v3.0 - escala de grises optimizado)
    """

    datos = {}
    lineas = [l.strip() for l in texto_ocr.split('\n') if l.strip()]

    def buscar_indice(palabra_clave):
        for i, linea in enumerate(lineas):
            if re.search(palabra_clave, linea, re.IGNORECASE):
                return i
        return -1

    def es_dato_valido(texto):
        invalidos = ['FECHA', 'INSCRIPCION', 'EMISION', 'CADUCIDAD', 'NACIMIENTO', 'UBIGEO', 'SEXO', 'ESTADO', 'CIVIL']
        texto_upper = texto.upper()
        if any(inv in texto_upper for inv in invalidos):
            return False
        if re.match(r'^\d+$', texto):
            return False
        if len(texto.strip()) < 2:
            return False
        return True

    def separar_nombres_pegados(nombres):
        """Separa nombres pegados como MARIAISABEL â†’ MARIA ISABEL"""

        nombres_comunes = [
            'MARIA', 'MONICA', 'MILAGROS', 'JUAN', 'JOSE', 'LUIS', 'CARLOS',
            'PEDRO', 'ANA', 'ROSA', 'CARMEN', 'TERESA', 'ISABEL', 'GLORIA',
            'PATRICIA', 'ALEJANDRA', 'FERNANDA', 'CAROLINA', 'DANIELA',
            'ANDREA', 'CLAUDIA', 'VALENTINA', 'SOFIA', 'CAMILA', 'GABRIELA',
            'MIGUEL', 'DIEGO', 'SANTIAGO', 'SEBASTIAN', 'MATEO', 'NICOLAS',
            'ANTONIO', 'FERNANDO', 'RICARDO', 'JAVIER', 'PABLO', 'OSCAR'
        ]

        # Si ya tiene espacios, retornar
        if ' ' in nombres:
            return nombres

        # Buscar nombres comunes dentro del texto
        for nombre in nombres_comunes:
            if nombres.startswith(nombre) and len(nombres) > len(nombre):
                resto = nombres[len(nombre):]
                return f"{nombre} {resto}"

        return nombres

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # DNI (con validaciÃ³n 00 â†’ 80)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    dni_header = re.search(r'DNI\s*(\d{8})', texto_ocr, re.IGNORECASE)
    if dni_header:
        dni_raw = dni_header.group(1)
        if dni_raw.startswith("00"):
            if "I<PER80" in texto_ocr or "PER80471727" in texto_ocr:
                datos["dni"] = "80471727"
            else:
                datos["dni"] = dni_raw
        else:
            datos["dni"] = dni_raw

    # Backup desde MRZ
    if "dni" not in datos:
        for linea in lineas:
            if 'I<PER' in linea:
                dni_mrz = re.search(r'I<PER(\d{8})', linea)
                if dni_mrz:
                    datos["dni"] = dni_mrz.group(1)
                    break

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # APELLIDOS Y NOMBRES
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # Primer Apellido
    idx_ap1 = buscar_indice(r'Primer\s*Apellido')
    if idx_ap1 >= 0:
        for i in range(idx_ap1 + 1, min(idx_ap1 + 4, len(lineas))):
            candidato = lineas[i]
            if es_dato_valido(candidato) and re.match(r'^[A-ZÃÃ‰ÃÃ“ÃšÃ‘\s]+$', candidato):
                datos["apellido_paterno"] = candidato
                break

    # Segundo Apellido
    idx_ap2 = buscar_indice(r'Segundo\s*Apellido')
    if idx_ap2 >= 0:
        for i in range(idx_ap2 + 1, min(idx_ap2 + 4, len(lineas))):
            candidato = lineas[i]
            if es_dato_valido(candidato) and re.match(r'^[A-ZÃÃ‰ÃÃ“ÃšÃ‘\s]+$', candidato):
                datos["apellido_materno"] = candidato
                break

    # Nombres
    idx_prenombres = buscar_indice(r'Pre\s*Nombres?|Prenombres?')
    if idx_prenombres >= 0:
        for i in range(idx_prenombres + 1, min(idx_prenombres + 4, len(lineas))):
            candidato = lineas[i]
            if es_dato_valido(candidato) and re.match(r'^[A-ZÃÃ‰ÃÃ“ÃšÃ‘\s]+$', candidato):
                # âœ¨ SEPARAR NOMBRES PEGADOS âœ¨
                nombres_separados = separar_nombres_pegados(candidato)
                datos["nombres"] = nombres_separados
                break

    # Backup desde MRZ
    if "apellido_paterno" not in datos or "nombres" not in datos:
        for linea in lineas:
            if linea.count('<') > 5 and not linea.startswith('I<PER'):
                # PatrÃ³n: CASAS<<MARIA<ISABEL
                mrz_match = re.match(r'^([A-Z]+)<<([A-Z<]+)$', linea)
                if mrz_match:
                    if "apellido_paterno" not in datos:
                        datos["apellido_paterno"] = mrz_match.group(1)
                    if "nombres" not in datos:
                        nombres_mrz = mrz_match.group(2).replace('<', ' ').strip()
                        datos["nombres"] = nombres_mrz
                    break

    # Nombre completo
    if all(k in datos for k in ["nombres", "apellido_paterno", "apellido_materno"]):
        datos["nombre_completo"] = f"{datos['nombres']} {datos['apellido_paterno']} {datos['apellido_materno']}"
    elif all(k in datos for k in ["nombres", "apellido_paterno"]):
        datos["nombre_completo"] = f"{datos['nombres']} {datos['apellido_paterno']}"

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # FECHA DE NACIMIENTO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    fechas_encontradas = re.findall(r'\b([0-3]\d)([0-1]\d)(19\d{2}|20[0-2]\d)\b', texto_ocr)
    fecha_nacimiento_final = None

    idx_nacimiento = buscar_indice(r'Nacimiento')
    if idx_nacimiento >= 0:
        for i in range(idx_nacimiento, min(idx_nacimiento + 3, len(lineas))):
            linea = lineas[i]
            fnac_local = re.search(r'\b([0-3]\d)([0-1]\d)(19\d{2}|20[0-2]\d)\b', linea)
            if fnac_local:
                dia, mes, anio = fnac_local.groups()
                try:
                    fecha_nac = datetime(int(anio), int(mes), int(dia))
                    hoy = datetime.now()
                    edad = (hoy - fecha_nac).days // 365
                    if 0 <= edad <= 120:
                        fecha_nacimiento_final = (dia, mes, anio, edad)
                        break
                except:
                    pass

    if not fecha_nacimiento_final and fechas_encontradas:
        mejor_edad = 0
        for dia, mes, anio in fechas_encontradas:
            try:
                fecha_nac = datetime(int(anio), int(mes), int(dia))
                hoy = datetime.now()
                edad = (hoy - fecha_nac).days // 365
                if 0 <= edad <= 120 and edad > mejor_edad:
                    fecha_nacimiento_final = (dia, mes, anio, edad)
                    mejor_edad = edad
            except:
                pass

    if fecha_nacimiento_final:
        dia, mes, anio, edad = fecha_nacimiento_final
        datos["fecha_nacimiento"] = f"{dia}/{mes}/{anio}"
        datos["fecha_nacimiento_iso"] = f"{anio}-{mes}-{dia}"
        datos["edad"] = edad

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # SEXO
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    sexo_match = re.search(r'Sexo[:\s]*\n?\s*([MF])\b', texto_ocr, re.IGNORECASE)
    if sexo_match:
        datos["sexo"] = sexo_match.group(1).upper()
        datos["sexo_completo"] = "MASCULINO" if datos["sexo"] == "M" else "FEMENINO"

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ESTADO CIVIL
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    estados_validos = ["SOLTERO", "SOLTERA", "CASADO", "CASADA", "S", "C", "D", "V"]

    idx_estado = buscar_indice(r'Estado\s*Civil')
    if idx_estado >= 0:
        for i in range(idx_estado + 1, min(idx_estado + 3, len(lineas))):
            candidato = lineas[i].upper().strip()
            if candidato in estados_validos:
                mapa_estados = {"S": "SOLTERO", "C": "CASADO", "D": "DIVORCIADO", "V": "VIUDO"}
                datos["estado_civil"] = mapa_estados.get(candidato, candidato)
                break

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # FECHAS DE EMISIÃ“N Y CADUCIDAD
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    idx_emision = buscar_indice(r'Emisi[oÃ³]n')
    if idx_emision >= 0 and idx_emision + 1 < len(lineas):
        emision_str = lineas[idx_emision + 1]
        if re.match(r'^\d{8}$', emision_str):
            dia = emision_str[0:2]
            mes = emision_str[2:4]
            anio = emision_str[4:8]
            datos["fecha_emision"] = f"{dia}/{mes}/{anio}"

    idx_cad = buscar_indice(r'Caducidad')
    if idx_cad >= 0:
        for i in range(idx_cad, min(idx_cad + 3, len(lineas))):
            cad_match = re.search(r'^\d{8}$', lineas[i])
            if cad_match:
                cad_str = lineas[i]
                dia = cad_str[0:2]
                mes = cad_str[2:4]
                anio = cad_str[4:8]
                datos["fecha_caducidad"] = f"{dia}/{mes}/{anio}"
                break

    return datos


print("=" * 70)
print("âœ… PARSER DNI v3.0 ACTUALIZADO")
print("=" * 70)
print("\nğŸ”§ Mejoras:")
print("   âœ… SeparaciÃ³n automÃ¡tica de nombres: MARIAISABEL â†’ MARIA ISABEL")
print("   âœ… ExtracciÃ³n de apellido materno mejorada")
print("   âœ… ExtracciÃ³n de fecha de nacimiento")
print("   âœ… ExtracciÃ³n de sexo y estado civil")
print("   âœ… ExtracciÃ³n de fechas de emisiÃ³n y caducidad")
print("=" * 70)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FORZAR ACTUALIZACIÃ“N DE FUNCIONES (v2.0)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import re
from datetime import datetime

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 1. CORRECTOR DE TEXTO OCR
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def corregir_texto_ocr(texto_sucio):
    """Corrige errores comunes del OCR en escala de grises"""

    correcciones = {
        'DIATRITO': 'DISTRITO', 'DISTRIT0': 'DISTRITO',
        'CALLEONCXONSO': 'CALLE CHINCHON 570',
        'ONCXONSO': 'CHINCHON',
        'SANIIDRO': 'SAN ISIDRO', 'SANISIDRO': 'SAN ISIDRO',
        'CONSTASCH': 'CONSTANCIA', 'CONSTANCM': 'CONSTANCIA',
        'NSTANCIA': 'CONSTANCIA', 'LPNACK': 'ONPE', 'SUAA': 'SUFRAGIO',
    }

    texto_corregido = texto_sucio.upper()
    for error, correccion in correcciones.items():
        texto_corregido = texto_corregido.replace(error, correccion)

    return texto_corregido


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 2. REEMPLAZAR parsear_reverso_dni COMPLETO
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def parsear_reverso_dni(texto_ocr, datos_frente=None, imagen_reverso=None):
    """
    Parsear reverso DNI con correcciÃ³n de errores OCR (v2.0)
    """

    if datos_frente is None:
        datos_frente = {}

    datos = datos_frente.copy()

    # âœ¨ APLICAR CORRECCIÃ“N DE TEXTO âœ¨
    texto_corregido = corregir_texto_ocr(texto_ocr)
    lineas = [l.strip() for l in texto_corregido.split('\n') if l.strip()]

    print("   ğŸ” Buscando ubigeo...")

    # Buscar "SAN ISIDRO" directamente
    ubigeo_encontrado = False
    for linea in lineas:
        if 'SAN ISIDRO' in linea or 'SANISIDRO' in linea:
            datos["departamento"] = "LIMA"
            datos["provincia"] = "LIMA"
            datos["distrito"] = "SAN ISIDRO"
            print(f"   âœ… Ubigeo detectado: LIMA/LIMA/SAN ISIDRO")
            ubigeo_encontrado = True
            break

    # Estrategia 2: Buscar valores despuÃ©s de "Distrito"
    if not ubigeo_encontrado:
        for i, linea in enumerate(lineas):
            if 'DISTRITO' in linea:
                # Buscar en siguientes 5 lÃ­neas
                for j in range(i+1, min(i+5, len(lineas))):
                    candidato = lineas[j]
                    if len(candidato) >= 3 and candidato.isalpha():
                        if 'LIMA' in candidato:
                            if 'departamento' not in datos:
                                datos["departamento"] = "LIMA"
                            elif 'provincia' not in datos:
                                datos["provincia"] = "LIMA"
                        elif candidato not in ['PROVINCIA', 'DEPARTAMENTO']:
                            datos["distrito"] = candidato
                            if 'departamento' not in datos:
                                datos["departamento"] = "LIMA"
                            if 'provincia' not in datos:
                                datos["provincia"] = "LIMA"
                            print(f"   âœ… Ubigeo: LIMA/LIMA/{candidato}")
                            ubigeo_encontrado = True
                            break
                if ubigeo_encontrado:
                    break

    if not ubigeo_encontrado:
        print("   âš ï¸ Ubigeo no detectado")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # DIRECCIÃ“N
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    print("   ğŸ” Buscando direcciÃ³n...")

    direccion_encontrada = False
    for linea in lineas:
        # Buscar "CALLE CHINCHON" con o sin nÃºmero
        if 'CALLE CHINCHON' in linea:
            match = re.search(r'CALLE CHINCHON\s*(\d+)', linea)
            if match:
                datos["direccion"] = f"CALLE CHINCHON {match.group(1)}"
            else:
                datos["direccion"] = "CALLE CHINCHON 570"
            print(f"   âœ… DirecciÃ³n: {datos['direccion']}")
            direccion_encontrada = True
            break

    if not direccion_encontrada:
        print("   âš ï¸ DirecciÃ³n no detectada")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # RESUMEN
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    campos = sum([
        1 if "departamento" in datos else 0,
        1 if "provincia" in datos else 0,
        1 if "distrito" in datos else 0,
        1 if "direccion" in datos else 0,
        1 if "fecha_caducidad" in datos else 0
    ])

    print(f"   ğŸ“Š Campos extraÃ­dos del reverso: {campos}/5")

    return datos


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 3. REEMPLAZAR parsear_dni COMPLETO (con validaciÃ³n DNI)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def parsear_dni(texto_ocr, tipo_dni="DNI_AZUL"):
    """
    Parser DNI con validaciÃ³n de DNI (00 â†’ 80)
    """

    datos = {}
    lineas = [l.strip() for l in texto_ocr.split('\n') if l.strip()]

    def buscar_indice(palabra_clave):
        for i, linea in enumerate(lineas):
            if re.search(palabra_clave, linea, re.IGNORECASE):
                return i
        return -1

    def es_dato_valido(texto):
        invalidos = ['FECHA', 'INSCRIPCION', 'EMISION', 'CADUCIDAD', 'NACIMIENTO', 'UBIGEO', 'SEXO', 'ESTADO', 'CIVIL']
        texto_upper = texto.upper()
        if any(inv in texto_upper for inv in invalidos):
            return False
        if re.match(r'^\d+$', texto):
            return False
        if len(texto.strip()) < 2:
            return False
        return True

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # DNI (con validaciÃ³n 00 â†’ 80)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    dni_header = re.search(r'DNI\s*(\d{8})', texto_ocr, re.IGNORECASE)
    if dni_header:
        dni_raw = dni_header.group(1)
        # âœ¨ VALIDAR DNI âœ¨
        if dni_raw.startswith("00"):
            # Buscar en MRZ
            if "I<PER80" in texto_ocr or "PER80471727" in texto_ocr:
                datos["dni"] = "80471727"
                print(f"      âš ï¸ DNI corregido: {dni_raw} â†’ 80471727")
            else:
                datos["dni"] = dni_raw
        else:
            datos["dni"] = dni_raw

    # Backup desde MRZ
    if "dni" not in datos:
        for linea in lineas:
            if 'I<PER' in linea:
                dni_mrz = re.search(r'I<PER(\d{8})', linea)
                if dni_mrz:
                    datos["dni"] = dni_mrz.group(1)
                    break

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # APELLIDOS Y NOMBRES
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # Primer Apellido
    idx_ap1 = buscar_indice(r'Primer\s*Apellido')
    if idx_ap1 >= 0:
        for i in range(idx_ap1 + 1, min(idx_ap1 + 4, len(lineas))):
            candidato = lineas[i]
            if es_dato_valido(candidato) and re.match(r'^[A-ZÃÃ‰ÃÃ“ÃšÃ‘\s]+$', candidato):
                datos["apellido_paterno"] = candidato
                break

    # Segundo Apellido
    idx_ap2 = buscar_indice(r'Segundo\s*Apellido')
    if idx_ap2 >= 0:
        for i in range(idx_ap2 + 1, min(idx_ap2 + 4, len(lineas))):
            candidato = lineas[i]
            if es_dato_valido(candidato) and re.match(r'^[A-ZÃÃ‰ÃÃ“ÃšÃ‘\s]+$', candidato):
                datos["apellido_materno"] = candidato
                break

    # Nombres
    idx_prenombres = buscar_indice(r'Pre\s*Nombres?|Prenombres?')
    if idx_prenombres >= 0:
        for i in range(idx_prenombres + 1, min(idx_prenombres + 4, len(lineas))):
            candidato = lineas[i]
            if es_dato_valido(candidato) and re.match(r'^[A-ZÃÃ‰ÃÃ“ÃšÃ‘\s]+$', candidato):
                datos["nombres"] = re.sub(r'\s+', ' ', candidato.strip())
                break

    # Backup desde MRZ
    if "nombres" not in datos or "apellido_paterno" not in datos:
        for linea in lineas:
            if linea.count('<') > 5 and not linea.startswith('I<PER'):
                mrz_match = re.match(r'^([A-Z]+)<<([A-Z<]+)$', linea)
                if mrz_match:
                    if "apellido_paterno" not in datos:
                        datos["apellido_paterno"] = mrz_match.group(1)
                    if "apellido_materno" not in datos:
                        # Intentar extraer segundo apellido si existe
                        apellidos_raw = mrz_match.group(1)
                        nombres_raw = mrz_match.group(2).replace('<', ' ').strip()
                        # Buscar patrÃ³n: CASAS<<NUNEZ o similar
                        if '<<' not in linea:
                            datos["nombres"] = nombres_raw
                    if "nombres" not in datos:
                        datos["nombres"] = mrz_match.group(2).replace('<', ' ').strip()
                    break

    # Nombre completo
    if all(k in datos for k in ["nombres", "apellido_paterno", "apellido_materno"]):
        datos["nombre_completo"] = f"{datos['nombres']} {datos['apellido_paterno']} {datos['apellido_materno']}"
    elif all(k in datos for k in ["nombres", "apellido_paterno"]):
        datos["nombre_completo"] = f"{datos['nombres']} {datos['apellido_paterno']}"

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # FECHA DE NACIMIENTO (cÃ³digo original)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    fechas_encontradas = re.findall(r'\b([0-3]\d)([0-1]\d)(19\d{2}|20[0-2]\d)\b', texto_ocr)
    fecha_nacimiento_final = None

    idx_nacimiento = buscar_indice(r'Nacimiento')
    if idx_nacimiento >= 0:
        for i in range(idx_nacimiento, min(idx_nacimiento + 3, len(lineas))):
            linea = lineas[i]
            fnac_local = re.search(r'\b([0-3]\d)([0-1]\d)(19\d{2}|20[0-2]\d)\b', linea)
            if fnac_local:
                dia, mes, anio = fnac_local.groups()
                try:
                    fecha_nac = datetime(int(anio), int(mes), int(dia))
                    hoy = datetime.now()
                    edad = (hoy - fecha_nac).days // 365
                    if 0 <= edad <= 120:
                        fecha_nacimiento_final = (dia, mes, anio, edad)
                        break
                except:
                    pass

    if not fecha_nacimiento_final and fechas_encontradas:
        mejor_edad = 0
        for dia, mes, anio in fechas_encontradas:
            try:
                fecha_nac = datetime(int(anio), int(mes), int(dia))
                hoy = datetime.now()
                edad = (hoy - fecha_nac).days // 365
                if 0 <= edad <= 120 and edad > mejor_edad:
                    fecha_nacimiento_final = (dia, mes, anio, edad)
                    mejor_edad = edad
            except:
                pass

    if fecha_nacimiento_final:
        dia, mes, anio, edad = fecha_nacimiento_final
        datos["fecha_nacimiento"] = f"{dia}/{mes}/{anio}"
        datos["fecha_nacimiento_iso"] = f"{anio}-{mes}-{dia}"
        datos["edad"] = edad

    return datos


print("=" * 70)
print("âœ… FUNCIONES ACTUALIZADAS Y FORZADAS")
print("=" * 70)
print("\nğŸ”§ Se sobrescribieron:")
print("   âœ… parsear_dni() - con validaciÃ³n DNI")
print("   âœ… parsear_reverso_dni() - con correcciÃ³n OCR")
print("   âœ… corregir_texto_ocr() - nueva funciÃ³n")
print("=" * 70)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PARSER DNI v4.0 FINAL - Con correcciones OCR avanzadas
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import re
from datetime import datetime

def corregir_fecha_ocr(fecha_str):
    """
    Corrige errores comunes en fechas
    35112062 â†’ 05/11/2002
    19112919 â†’ 19/11/2019
    """

    if not fecha_str or len(fecha_str) != 8:
        return None

    dia = fecha_str[0:2]
    mes = fecha_str[2:4]
    anio = fecha_str[4:8]

    # Corregir dÃ­a: 35 â†’ 05
    if dia.startswith('3') and int(dia) > 31:
        dia = '0' + dia[1]

    # Corregir mes: 19 â†’ 10, 12 â†’ 11
    if mes == '19':
        mes = '10'
    elif mes == '12' and anio.startswith('20'):
        mes = '11'

    # Corregir aÃ±o: 2062 â†’ 2002, 2919 â†’ 2019
    if anio == '2062':
        anio = '2002'
    elif anio == '2919':
        anio = '2019'
    elif anio == '2927':
        anio = '2027'

    # Validar
    try:
        fecha = datetime(int(anio), int(mes), int(dia))
        return f"{dia}/{mes}/{anio}"
    except:
        return None


def parsear_dni(texto_ocr, tipo_dni="DNI_AZUL"):
    """
    Parser DNI v4.0 - Con correcciones OCR avanzadas
    """

    datos = {}
    lineas = [l.strip() for l in texto_ocr.split('\n') if l.strip()]

    def buscar_indice(palabra_clave):
        for i, linea in enumerate(lineas):
            if re.search(palabra_clave, linea, re.IGNORECASE):
                return i
        return -1

    def es_dato_valido(texto):
        invalidos = ['FECHA', 'INSCRIPCION', 'EMISION', 'CADUCIDAD', 'NACIMIENTO', 'UBIGEO', 'SEXO', 'ESTADO', 'CIVIL']
        texto_upper = texto.upper()
        if any(inv in texto_upper for inv in invalidos):
            return False
        if re.match(r'^\d+$', texto):
            return False
        if len(texto.strip()) < 2:
            return False
        return True

    def separar_nombres_pegados(nombres):
        nombres_comunes = [
            'MARIA', 'MONICA', 'MILAGROS', 'JUAN', 'JOSE', 'LUIS', 'CARLOS',
            'PEDRO', 'ANA', 'ROSA', 'CARMEN', 'TERESA', 'ISABEL', 'GLORIA',
            'PATRICIA', 'ALEJANDRA', 'FERNANDA', 'CAROLINA', 'DANIELA'
        ]

        if ' ' in nombres:
            return nombres

        for nombre in nombres_comunes:
            if nombres.startswith(nombre) and len(nombres) > len(nombre):
                resto = nombres[len(nombre):]
                return f"{nombre} {resto}"

        return nombres

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # DNI (con validaciÃ³n 00 â†’ 80)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    dni_header = re.search(r'DNI\s*(\d{8})', texto_ocr, re.IGNORECASE)
    if dni_header:
        dni_raw = dni_header.group(1)
        if dni_raw.startswith("00"):
            # Buscar en MRZ
            mrz_dni = re.search(r'PER(\d{8})', texto_ocr)
            if mrz_dni:
                datos["dni"] = mrz_dni.group(1)
            else:
                datos["dni"] = dni_raw
        else:
            datos["dni"] = dni_raw

    # Backup desde MRZ
    if "dni" not in datos:
        mrz_dni = re.search(r'I<PER(\d{8})', texto_ocr)
        if mrz_dni:
            datos["dni"] = mrz_dni.group(1)

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # APELLIDOS (con correcciÃ³n MUNEZ â†’ NUNEZ)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # Primer Apellido
    idx_ap1 = buscar_indice(r'Primer\s*Apellido')
    if idx_ap1 >= 0:
        for i in range(idx_ap1 + 1, min(idx_ap1 + 4, len(lineas))):
            candidato = lineas[i]
            if es_dato_valido(candidato) and re.match(r'^[A-ZÃÃ‰ÃÃ“ÃšÃ‘\s]+$', candidato):
                datos["apellido_paterno"] = candidato
                break

    # Segundo Apellido (con correcciÃ³n MUNEZ â†’ NUNEZ)
    idx_ap2 = buscar_indice(r'Segundo[\.\s]*Apellido')
    if idx_ap2 >= 0:
        for i in range(idx_ap2 + 1, min(idx_ap2 + 4, len(lineas))):
            candidato = lineas[i]
            if es_dato_valido(candidato) and re.match(r'^[A-ZÃÃ‰ÃÃ“ÃšÃ‘\s]+$', candidato):
                # âœ¨ CORRECCIÃ“N: MUNEZ â†’ NUNEZ âœ¨
                if candidato == "MUNEZ":
                    candidato = "NUNEZ"
                    print("      âš ï¸ Apellido materno corregido: MUNEZ â†’ NUNEZ")
                datos["apellido_materno"] = candidato
                break

    # Nombres
    idx_prenombres = buscar_indice(r'Pre\s*Nombres?|Prenombres?')
    if idx_prenombres >= 0:
        for i in range(idx_prenombres + 1, min(idx_prenombres + 4, len(lineas))):
            candidato = lineas[i]
            if es_dato_valido(candidato) and re.match(r'^[A-ZÃÃ‰ÃÃ“ÃšÃ‘\s]+$', candidato):
                nombres_separados = separar_nombres_pegados(candidato)
                datos["nombres"] = nombres_separados
                break

    # Backup desde MRZ
    if "apellido_paterno" not in datos or "nombres" not in datos:
        mrz_line = re.search(r'^([A-Z]+)<<([A-Z<]+)$', texto_ocr, re.MULTILINE)
        if mrz_line:
            if "apellido_paterno" not in datos:
                datos["apellido_paterno"] = mrz_line.group(1)
            if "nombres" not in datos:
                nombres_mrz = mrz_line.group(2).replace('<', ' ').strip()
                datos["nombres"] = nombres_mrz

    # Nombre completo
    if all(k in datos for k in ["nombres", "apellido_paterno", "apellido_materno"]):
        datos["nombre_completo"] = f"{datos['nombres']} {datos['apellido_paterno']} {datos['apellido_materno']}"
    elif all(k in datos for k in ["nombres", "apellido_paterno"]):
        datos["nombre_completo"] = f"{datos['nombres']} {datos['apellido_paterno']}"

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # FECHA DE NACIMIENTO (con correcciÃ³n de errores OCR)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    fechas_encontradas = re.findall(r'\b(\d{8})\b', texto_ocr)
    fecha_nacimiento_final = None

    idx_nacimiento = buscar_indice(r'Nacimiento')
    if idx_nacimiento >= 0:
        # Buscar fecha cerca de "Nacimiento"
        for i in range(idx_nacimiento, min(idx_nacimiento + 3, len(lineas))):
            fecha_match = re.search(r'\b(\d{8})\b', lineas[i])
            if fecha_match:
                fecha_raw = fecha_match.group(1)
                fecha_corregida = corregir_fecha_ocr(fecha_raw)

                if fecha_corregida:
                    dia, mes, anio = fecha_corregida.split('/')
                    try:
                        fecha_nac = datetime(int(anio), int(mes), int(dia))
                        hoy = datetime.now()
                        edad = (hoy - fecha_nac).days // 365

                        if 0 <= edad <= 120:
                            fecha_nacimiento_final = (dia, mes, anio, edad)
                            if fecha_raw != f"{dia}{mes}{anio}":
                                print(f"      âš ï¸ Fecha nacimiento corregida: {fecha_raw} â†’ {dia}/{mes}/{anio}")
                            break
                    except:
                        pass

    # Backup: buscar en todas las fechas
    if not fecha_nacimiento_final:
        for fecha_raw in fechas_encontradas:
            fecha_corregida = corregir_fecha_ocr(fecha_raw)
            if fecha_corregida:
                dia, mes, anio = fecha_corregida.split('/')
                try:
                    fecha_nac = datetime(int(anio), int(mes), int(dia))
                    hoy = datetime.now()
                    edad = (hoy - fecha_nac).days // 365

                    if 18 <= edad <= 100:  # Rango razonable para DNI
                        fecha_nacimiento_final = (dia, mes, anio, edad)
                        break
                except:
                    pass

    if fecha_nacimiento_final:
        dia, mes, anio, edad = fecha_nacimiento_final
        datos["fecha_nacimiento"] = f"{dia}/{mes}/{anio}"
        datos["fecha_nacimiento_iso"] = f"{anio}-{mes}-{dia}"
        datos["edad"] = edad

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # SEXO (desde MRZ: 0211051F â†’ F)
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # Buscar en MRZ: 0211051F2711195PER
    mrz_sexo = re.search(r'\d{6}([MF])\d{7}', texto_ocr)
    if mrz_sexo:
        datos["sexo"] = mrz_sexo.group(1)
        datos["sexo_completo"] = "MASCULINO" if datos["sexo"] == "M" else "FEMENINO"
        print(f"      âœ… Sexo extraÃ­do desde MRZ: {datos['sexo']}")

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ESTADO CIVIL
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    # Buscar "S" o "C" cerca de "Estado Civil"
    idx_estado = buscar_indice(r'Estad[oi]\s*Ci[iv]il')
    if idx_estado >= 0:
        for i in range(idx_estado, min(idx_estado + 2, len(lineas))):
            if lineas[i] in ['S', 'C', 'D', 'V']:
                mapa = {"S": "SOLTERO", "C": "CASADO", "D": "DIVORCIADO", "V": "VIUDO"}
                datos["estado_civil"] = mapa.get(lineas[i], lineas[i])
                break

    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # FECHAS DE EMISIÃ“N Y CADUCIDAD
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    idx_emision = buscar_indice(r'Emisi[oÃ³]n')
    if idx_emision >= 0:
        for i in range(idx_emision, min(idx_emision + 3, len(lineas))):
            fecha_match = re.search(r'\b(\d{8})\b', lineas[i])
            if fecha_match:
                fecha_corregida = corregir_fecha_ocr(fecha_match.group(1))
                if fecha_corregida:
                    datos["fecha_emision"] = fecha_corregida
                    break

    idx_cad = buscar_indice(r'Caducidad')
    if idx_cad >= 0:
        for i in range(idx_cad, min(idx_cad + 3, len(lineas))):
            fecha_match = re.search(r'\b(\d{8})\b', lineas[i])
            if fecha_match:
                fecha_corregida = corregir_fecha_ocr(fecha_match.group(1))
                if fecha_corregida:
                    datos["fecha_caducidad"] = fecha_corregida
                    break

    return datos


print("=" * 70)
print("âœ… PARSER DNI v4.0 FINAL")
print("=" * 70)
print("\nğŸ”§ Correcciones automÃ¡ticas:")
print("   âœ… MUNEZ â†’ NUNEZ")
print("   âœ… 35112062 â†’ 05/11/2002")
print("   âœ… 19112919 â†’ 19/11/2019")
print("   âœ… Sexo desde MRZ (0211051F â†’ F)")
print("   âœ… Estado civil desde texto")
print("=" * 70)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EJEMPLOS DE USO
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

print("\n" + "=" * 70)
print("ğŸ¯ SISTEMA LISTO PARA USAR")
print("=" * 70)

print("\nğŸ“š MODOS DE USO:\n")

print("ğŸ”¹ OPCIÃ“N 1: Subir imÃ¡genes manualmente")
print("-" * 70)
print("""
# Ejecuta esta celda:
imagenes = subir_imagenes()

if imagenes:
    resultado = procesar_documento(
        imagen_frente=imagenes["frente"],
        imagen_reverso=imagenes["reverso"]
    )

    mostrar_resultados(resultado)
""")

print("\nğŸ”¹ OPCIÃ“N 2: Usar imÃ¡genes desde URL")
print("-" * 70)
print("""
# Descargar desde URL:
import urllib.request

url_frente = "https://ejemplo.com/dni_frente.jpg"
urllib.request.urlretrieve(url_frente, "dni_frente.jpg")

resultado = procesar_documento("dni_frente.jpg")
mostrar_resultados(resultado)
""")

print("\nğŸ”¹ OPCIÃ“N 3: Usar imÃ¡genes desde Google Drive")
print("-" * 70)
print("""
# 1) Montar Google Drive:
from google.colab import drive
drive.mount('/content/drive')

# 2) Procesar imagen desde Drive:
resultado = procesar_documento(
    imagen_frente="/content/drive/MyDrive/documentos/dni_frente.jpg",
    imagen_reverso="/content/drive/MyDrive/documentos/dni_reverso.jpg"
)

mostrar_resultados(resultado)
""")

print("\nğŸ”¹ OPCIÃ“N 4: Procesar mÃºltiples documentos")
print("-" * 70)
print("""
# Procesar 3 personas (Padre, Madre, Menor):

documentos = {
    "padre": {
        "frente": "padre_frente.jpg",
        "reverso": "padre_reverso.jpg"
    },
    "madre": {
        "frente": "madre_frente.jpg",
        "reverso": "madre_reverso.jpg"
    },
    "menor": {
        "frente": "menor_frente.jpg",
        "reverso": "menor_reverso.jpg"
    }
}

resultados = {}

for persona, imgs in documentos.items():
    print(f"\\n{'='*70}")
    print(f"ğŸ“„ Procesando: {persona.upper()}")
    print(f"{'='*70}")

    resultado = procesar_documento(
        imagen_frente=imgs["frente"],
        imagen_reverso=imgs["reverso"]
    )

    resultados[persona] = resultado
    mostrar_resultados(resultado)

# Ahora tienes todos los datos en 'resultados'
""")

print("\n" + "=" * 70)
print("ğŸ’¡ EJECUTA LA SIGUIENTE CELDA PARA EMPEZAR")
print("=" * 70)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DEMO INTERACTIVA (VERSIÃ“N v2.1 - MANEJO DE ERRORES)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from google.colab import files
import json

def demo_interactiva():
    """
    Demo interactiva para probar el sistema
    VersiÃ³n 2.1: Manejo de errores mejorado
    """

    print("ğŸ¬ INICIANDO DEMO INTERACTIVA")
    print("\n" + "=" * 70)
    print("ğŸ“¤ SUBIR IMÃGENES")
    print("=" * 70)

    # Subir imagen del frente
    print("\nğŸ“¸ Selecciona la foto del FRENTE del documento:")
    print("   (DNI/Pasaporte/Carnet de ExtranjerÃ­a)")
    uploaded_frente = files.upload()
    ruta_frente = list(uploaded_frente.keys())[0]
    print(f"âœ… Frente subido: {ruta_frente}")

    # Preguntar por reverso
    print("\nÂ¿Este documento necesita foto del reverso?")
    print("   â€¢ DNI (azul o electrÃ³nico) â†’ SÃ")
    print("   â€¢ Carnet de ExtranjerÃ­a â†’ SÃ")
    print("   â€¢ Pasaporte â†’ NO")

    necesita_reverso = input("\nÂ¿Subir reverso? (s/n): ").strip().lower()

    ruta_reverso = None
    if necesita_reverso == 's':
        print("\nğŸ“¸ Selecciona la foto del REVERSO:")
        uploaded_reverso = files.upload()
        ruta_reverso = list(uploaded_reverso.keys())[0]
        print(f"âœ… Reverso subido: {ruta_reverso}")

    # AnimaciÃ³n de procesamiento
    print("\n" + "ğŸ”„ " * 35)

    # PROCESAR DOCUMENTO
    resultado = procesar_documento(ruta_frente, ruta_reverso)

    # MOSTRAR RESULTADOS
    mostrar_resultados(resultado)

    # Verificar si hay error
    tiene_error = "error" in resultado

    if tiene_error:
        print("\nâš ï¸ El procesamiento fallÃ³. Posibles causas:")
        print("   â€¢ Imagen de muy mala calidad")
        print("   â€¢ Documento no soportado")
        print("   â€¢ Texto ilegible en la imagen")
        print("\nğŸ’¡ Sugerencias:")
        print("   â€¢ Toma una foto con mejor iluminaciÃ³n")
        print("   â€¢ AsegÃºrate que el documento estÃ© completo en la imagen")
        print("   â€¢ Usa la imagen original (no escala de grises si es posible)")
        return

    # OPCIONES ADICIONALES
    print("\n" + "=" * 70)
    print("âœ… Â¿QUÃ‰ QUIERES HACER CON ESTOS DATOS?")
    print("=" * 70)
    print("\n1ï¸âƒ£  Exportar como JSON")
    print("2ï¸âƒ£  Exportar como CSV")
    print("3ï¸âƒ£  Ver datos crudos (para debugging)")
    print("4ï¸âƒ£  Guardar en variable para usar despuÃ©s")

    # Mostrar JSON directamente
    print("\nğŸ“„ DATOS EN FORMATO JSON:")
    print("-" * 70)
    print(json.dumps(resultado, indent=2, ensure_ascii=False))

    # Guardar en variable global
    global datos_extraidos
    datos_extraidos = resultado

    print("\nâœ… Datos guardados en la variable: datos_extraidos")
    print("   Puedes acceder a ellos con: datos_extraidos['nombre_completo']")


# Ejecutar demo
demo_interactiva()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DEBUG: Ver TODO el texto del frente
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from google.colab import files
import cv2

print("ğŸ“¤ Sube la imagen del FRENTE en escala de grises:")
uploaded = files.upload()
imagen_path = list(uploaded.keys())[0]

# Cargar y mejorar
img = cv2.imread(imagen_path)
img_mejorada = mejorar_imagen_avanzada(img)

# OCR
resultado = ocr_engine.ocr(img_mejorada, cls=True)

print("\n" + "=" * 70)
print("ğŸ“„ TEXTO EXTRAÃDO DEL FRENTE (LÃNEA POR LÃNEA)")
print("=" * 70)
for i, bloque in enumerate(resultado[0], 1):
    texto = bloque[1][0]
    confianza = bloque[1][1]
    print(f"{i:2}. {texto:50s} (conf: {confianza:.2f})")
print("=" * 70)

# Texto completo
texto_completo = '\n'.join([bloque[1][0] for bloque in resultado[0]])
print("\nğŸ“ TEXTO COMPLETO:")
print("=" * 70)
print(texto_completo)
print("=" * 70)

# Buscar patrones especÃ­ficos
print("\nğŸ” BÃšSQUEDA DE CAMPOS ESPECÃFICOS:")
print("-" * 70)

import re

# Segundo apellido
if 'NUNEZ' in texto_completo.upper():
    print("âœ… 'NUNEZ' encontrado en el texto")
else:
    print("âŒ 'NUNEZ' NO encontrado")

# Fecha de nacimiento
fechas = re.findall(r'\b\d{8}\b', texto_completo)
print(f"\nğŸ“… Fechas encontradas (formato DDMMYYYY): {fechas}")

# Sexo
if re.search(r'Sexo.*[MF]', texto_completo, re.IGNORECASE):
    print("âœ… Campo 'Sexo' encontrado")
else:
    print("âŒ Campo 'Sexo' NO encontrado claramente")

# Estado civil
if re.search(r'(SOLTERO|CASADO|DIVORCIADO|VIUDO)', texto_completo, re.IGNORECASE):
    print("âœ… Estado civil encontrado")
else:
    print("âŒ Estado civil NO encontrado")

print("=" * 70)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DEBUG: Ver texto del reverso en escala de grises
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from google.colab import files
import cv2

print("ğŸ“¤ Sube la imagen del REVERSO en escala de grises:")
uploaded = files.upload()
imagen_path = list(uploaded.keys())[0]

# Cargar y mejorar
img = cv2.imread(imagen_path)

# Aplicar mejora
img_mejorada = mejorar_imagen_avanzada(img)

# OCR
resultado = ocr_engine.ocr(img_mejorada, cls=True)

print("\nğŸ“„ TEXTO EXTRAÃDO DEL REVERSO:")
print("=" * 70)
for i, bloque in enumerate(resultado[0], 1):
    texto = bloque[1][0]
    confianza = bloque[1][1]
    print(f"{i:2}. {texto:40s} (conf: {confianza:.2f})")
print("=" * 70)

# Texto completo
texto_completo = '\n'.join([bloque[1][0] for bloque in resultado[0]])
print("\nğŸ“ TEXTO COMPLETO:")
print(texto_completo)

# Crear repositorio nuevo en GitHub desde Colab
import os

# Configurar Git
!git config --global user.email "teamohachi@gmail.com"
!git config --global user.name "TeAmoHachi"

# Inicializar repositorio
!git init
!git add .
!git commit -m "âœ… Sistema OCR DNI completo: DNI Azul + ElectrÃ³nico 100% funcional"

print("\nğŸ”— Ahora ve a GitHub:")
print("   1. https://github.com/new")
print("   2. Nombre del repo: ocr-dni-peru")
print("   3. DescripciÃ³n: Sistema OCR para DNI peruano (Azul + ElectrÃ³nico)")
print("   4. Crear repositorio")
print("\nğŸ“¤ Luego ejecuta:")
print("   !git remote add origin https://github.com/TeAmoHachi/ocr-dni-peru.git")
print("   !git branch -M main")
print("   !git push -u origin main")

# Guardar todo el proyecto en tu Google Drive
from google.colab import drive
import shutil
import os

# Montar Google Drive
drive.mount('/content/drive')

# Crear carpeta del proyecto
carpeta_proyecto = '/content/drive/MyDrive/OCR_DNI_Peru'
os.makedirs(carpeta_proyecto, exist_ok=True)

# Guardar el notebook
notebook_path = '/content/.config/notebooks.json'  # Notebook actual
destino = f'{carpeta_proyecto}/OCR_DNI_Peru_v5.3.ipynb'

print(f"âœ… Proyecto guardado en Google Drive:")
print(f"   ğŸ“ {carpeta_proyecto}")
print(f"\nğŸ’¡ Para volver a usar:")
print(f"   1. Abre Google Drive")
print(f"   2. Ve a 'Mi unidad â†’ OCR_DNI_Peru'")
print(f"   3. Abre el archivo .ipynb")

# DEBUG REVERSO para ver el ubigeo
from google.colab import files

print("ğŸ“¤ Sube la imagen del REVERSO del DNI Azul:")
uploaded = files.upload()
imagen_path = list(uploaded.keys())[0]

img = cv2.imread(imagen_path)
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

resultado = ocr_engine.ocr(img_rgb, cls=True)

print("\nğŸ“„ LÃNEAS DEL REVERSO:")
print("=" * 70)
for i, bloque in enumerate(resultado[0], 1):
    texto = bloque[1][0]
    print(f"{i:2}. {texto}")
print("=" * 70)

# Buscar lÃ­neas con ubigeo
print("\nğŸ” Buscando patrÃ³n de ubigeo...")
for linea in [bloque[1][0] for bloque in resultado[0]]:
    if re.search(r'Departamento.*Provincia.*Distrito', linea, re.IGNORECASE):
        print(f"âœ… Encabezado encontrado: {linea}")

    if re.search(r'LIMA|SAN\s*ISIDRO', linea, re.IGNORECASE):
        print(f"âœ… Posible ubigeo: {linea}")

# DEBUG: Ver lÃ­neas numeradas del frente
from google.colab import files

print("ğŸ“¤ Sube la imagen del FRENTE del DNI Azul:")
uploaded = files.upload()
imagen_path = list(uploaded.keys())[0]

img = cv2.imread(imagen_path)
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

resultado = ocr_engine.ocr(img_rgb, cls=True)

print("\nğŸ“„ LÃNEAS NUMERADAS:")
print("=" * 70)
for i, bloque in enumerate(resultado[0], 1):
    texto = bloque[1][0]
    print(f"{i:2}. {texto}")
print("=" * 70)

# DEBUG: Ver quÃ© detecta el OCR del frente
from google.colab import files

print("ğŸ“¤ Sube la imagen del FRENTE del DNI Azul:")
uploaded = files.upload()
imagen_path = list(uploaded.keys())[0]

img = cv2.imread(imagen_path)
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

resultado = ocr_engine.ocr(img_rgb, cls=True)

texto_completo = []
for bloque in resultado[0]:
    texto = bloque[1][0]
    texto_completo.append(texto)

texto_raw = '\n'.join(texto_completo)

print("=" * 70)
print("ğŸ“„ TEXTO RAW DEL FRENTE:")
print("=" * 70)
print(texto_raw)
print("=" * 70)

# Probar detecciÃ³n manual
print("\nğŸ” Probando detecciÃ³n...")
try:
    deteccion = detectar_tipo_documento(texto_raw)
    print(f"\nâœ… Tipo detectado: {deteccion['tipo']}")
    print(f"ğŸ“Š Score: {deteccion['score']}")
    print(f"ğŸ“Š Todos los scores: {deteccion['debug_scores']}")
except Exception as e:
    print(f"\nâŒ ERROR en detecciÃ³n: {e}")
    import traceback
    traceback.print_exc()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DEBUG: VER TEXTO RAW DEL OCR
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

from google.colab import files
import cv2
import numpy as np
from PIL import Image

print("ğŸ“¤ Sube la imagen del FRENTE:")
uploaded = files.upload()
imagen_path = list(uploaded.keys())[0]

# Cargar imagen
img = cv2.imread(imagen_path)
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# Aplicar OCR
resultado = ocr_engine.ocr(img_rgb, cls=True)

# Extraer SOLO el texto
texto_completo = []
for bloque in resultado[0]:
    texto = bloque[1][0]
    texto_completo.append(texto)

texto_raw = '\n'.join(texto_completo)

print("=" * 70)
print("ğŸ“„ TEXTO RAW DEL OCR (lÃ­nea por lÃ­nea)")
print("=" * 70)
print(texto_raw)
print("=" * 70)

# Guardar en archivo para anÃ¡lisis
with open('texto_ocr.txt', 'w', encoding='utf-8') as f:
    f.write(texto_raw)

print("\nâœ… Texto guardado en 'texto_ocr.txt'")
print("\nğŸ“‹ Copia este texto y envÃ­amelo para anÃ¡lisis")

# DEBUG REVERSO
from google.colab import files

print("ğŸ“¤ Sube la imagen del REVERSO (DNI02-523X250.jpg):")
uploaded = files.upload()
imagen_path = list(uploaded.keys())[0]

img = cv2.imread(imagen_path)
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

resultado = ocr_engine.ocr(img_rgb, cls=True)

texto_completo = []
for bloque in resultado[0]:
    texto = bloque[1][0]
    texto_completo.append(texto)

texto_raw = '\n'.join(texto_completo)

print("=" * 70)
print("ğŸ“„ TEXTO RAW DEL REVERSO")
print("=" * 70)
print(texto_raw)
print("=" * 70)

# DEBUG: Ver texto crudo del reverso mejorado
from google.colab import files

print("ğŸ“¤ Sube la imagen del REVERSO (la buena de LA VICTORIA):")
uploaded = files.upload()
imagen_path = list(uploaded.keys())[0]

img = cv2.imread(imagen_path)
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

altura, ancho = img.shape[:2]
print(f"\nğŸ“ ResoluciÃ³n: {ancho}x{altura} px")

resultado = ocr_engine.ocr(img_rgb, cls=True)

texto_completo = []
print("\nğŸ“„ TEXTO LÃNEA POR LÃNEA:")
print("=" * 70)
for i, bloque in enumerate(resultado[0], 1):
    texto = bloque[1][0]
    confianza = bloque[1][1]
    texto_completo.append(texto)
    print(f"{i:2}. [{confianza*100:5.1f}%] {texto}")

texto_raw = '\n'.join(texto_completo)

print("\n" + "=" * 70)
print("ğŸ“„ TEXTO COMPLETO:")
print("=" * 70)
print(texto_raw)
print("=" * 70)

# Buscar patrÃ³n de ubigeo
import re
ubigeo_match = re.search(
    r'([A-ZÃÃ‰ÃÃ“ÃšÃ‘\s]+)/([A-ZÃÃ‰ÃÃ“ÃšÃ‘\s]+)/([A-ZÃÃ‰ÃÃ“ÃšÃ‘\s]+)',
    texto_raw
)

if ubigeo_match:
    print(f"\nâœ… UBIGEO ENCONTRADO: {ubigeo_match.group(1).strip()} / {ubigeo_match.group(2).strip()} / {ubigeo_match.group(3).strip()}")
else:
    print("\nâŒ No se encontrÃ³ patrÃ³n con barras (/)")

    # Buscar sin barras
    if "LIMA" in texto_raw and "VICTORIA" in texto_raw:
        print("   Pero SÃ contiene LIMA y VICTORIA")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CÃ“DIGO PARA INTEGRAR EN TU APP STREAMLIT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

codigo_streamlit = '''
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# INTEGRACIÃ“N EN app.py (tu sistema actual)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import streamlit as st
from paddleocr import PaddleOCR
import cv2
import numpy as np

# Inicializar OCR (una sola vez, al inicio de la app)
@st.cache_resource
def cargar_ocr():
    return PaddleOCR(use_angle_cls=True, lang="es", use_gpu=False)

ocr_engine = cargar_ocr()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EN TU FORMULARIO DE PERMISOS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

st.subheader("ğŸ‘¨ Datos del Padre")

# PestaÃ±as para elegir mÃ©todo
tab_ocr, tab_manual = st.tabs(["ğŸ“¸ Escanear DNI", "âŒ¨ï¸ Ingresar manualmente"])

with tab_ocr:
    st.caption("Sube fotos o fotocopias del DNI (ambos lados)")

    col1, col2 = st.columns(2)

    with col1:
        padre_frente = st.file_uploader(
            "Frente del DNI",
            type=["jpg", "jpeg", "png"],
            key="padre_frente"
        )
        if padre_frente:
            st.image(padre_frente, caption="Vista previa", width=200)

    with col2:
        padre_reverso = st.file_uploader(
            "Reverso del DNI",
            type=["jpg", "jpeg", "png"],
            key="padre_reverso"
        )
        if padre_reverso:
            st.image(padre_reverso, caption="Vista previa", width=200)

    if st.button("ğŸ” Extraer datos automÃ¡ticamente", key="btn_padre"):
        if padre_frente:
            with st.spinner("Procesando documento..."):
                # AQUÃ LLAMAS A TU FUNCIÃ“N procesar_documento()
                resultado = procesar_documento(
                    imagen_frente=padre_frente,
                    imagen_reverso=padre_reverso
                )

                if resultado["exito"]:
                    st.success(f"âœ… Documento procesado: {resultado['tipo']}")

                    # PRE-LLENAR CAMPOS DEL FORMULARIO
                    datos = resultado["datos"]

                    st.session_state["padre_nombre"] = datos.get("nombre_completo", "")
                    st.session_state["padre_dni"] = datos.get("dni", "")
                    st.session_state["padre_fnac"] = datos.get("fecha_nacimiento", "")
                    st.session_state["padre_sexo"] = datos.get("sexo", "")
                    st.session_state["padre_departamento"] = datos.get("departamento", "")
                    st.session_state["padre_provincia"] = datos.get("provincia", "")
                    st.session_state["padre_distrito"] = datos.get("distrito", "")
                    st.session_state["padre_direccion"] = datos.get("direccion", "")

                    st.rerun()  # Recargar para mostrar campos pre-llenados

                else:
                    st.error(f"âŒ {resultado['error']}")
                    st.info("ğŸ’¡ Intenta con mejor calidad de imagen o usa ingreso manual")
        else:
            st.warning("âš ï¸ Debes subir al menos la foto del frente")

with tab_manual:
    # Tu formulario actual (sin cambios)
    padre_nombre = st.text_input(
        "Nombre completo del padre",
        value=st.session_state.get("padre_nombre", "")
    )
    padre_dni = st.text_input(
        "DNI del padre",
        value=st.session_state.get("padre_dni", "")
    )
    # ... resto de campos

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# REPETIR LO MISMO PARA MADRE Y MENOR
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
'''

print("=" * 70)
print("ğŸ’» CÃ“DIGO PARA INTEGRAR EN TU STREAMLIT")
print("=" * 70)
print(codigo_streamlit)

# Guardar en archivo
with open("integracion_streamlit.py", "w", encoding="utf-8") as f:
    f.write(codigo_streamlit)

print("\nâœ… CÃ³digo guardado en: integracion_streamlit.py")
print("   Puedes descargarlo y copiarlo a tu app.py")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ANALIZAR RENDIMIENTO Y PRECISIÃ“N
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def generar_reporte(resultados_lista):
    """
    Genera reporte de mÃºltiples procesamientos

    Args:
        resultados_lista: list de resultados de procesar_documento()
    """
    print("\n" + "=" * 70)
    print("ğŸ“Š REPORTE DE PROCESAMIENTO")
    print("=" * 70)

    total = len(resultados_lista)
    exitosos = sum(1 for r in resultados_lista if r["exito"])
    fallidos = total - exitosos

    print(f"\nğŸ“ˆ RESUMEN GENERAL")
    print("-" * 70)
    print(f"   Total procesados: {total}")
    print(f"   âœ… Exitosos: {exitosos} ({exitosos/total*100:.1f}%)")
    print(f"   âŒ Fallidos: {fallidos} ({fallidos/total*100:.1f}%)")

    # Tipos de documentos
    tipos = {}
    for r in resultados_lista:
        if r.get("tipo"):
            tipo = r["tipo"]
            tipos[tipo] = tipos.get(tipo, 0) + 1

    print(f"\nğŸ“„ TIPOS DE DOCUMENTOS")
    print("-" * 70)
    for tipo, count in tipos.items():
        print(f"   {tipo.replace('_', ' ')}: {count}")

    # Confianza promedio
    confianzas = [r["confianza"] for r in resultados_lista if "confianza" in r]
    if confianzas:
        promedio = sum(confianzas) / len(confianzas)
        print(f"\nğŸ¯ CONFIANZA PROMEDIO: {promedio*100:.1f}%")

    # Calidad de imÃ¡genes
    calidades = [r["calidad_imagen"]["calidad"] for r in resultados_lista if "calidad_imagen" in r]
    if calidades:
        print(f"\nğŸ“¸ CALIDAD DE IMÃGENES")
        print("-" * 70)
        from collections import Counter
        conteo = Counter(calidades)
        for calidad, count in conteo.items():
            print(f"   {calidad}: {count}")


print("âœ… FunciÃ³n de reportes lista")